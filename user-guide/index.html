<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">   
    <link rel="shortcut icon" href="../img/favicon.ico">

    <title>User Guide - clj-fakes</title>

    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">


    <link href="../custom.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">clj-fakes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Readme</a>
                    </li>
                
                
                
                    <li >
                        <a href="../quickstart/">Quickstart</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">User Guide</a>
                    </li>
                
                
                
                    <li >
                        <a href="../api/">API Reference</a>
                    </li>
                
                
                
                    <li >
                        <a href="../dev-guide/">Developer Guide</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../quickstart/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../api/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/metametadata/clj-fakes/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="first-level active"><a href="#namespaces">Namespaces</a></li>
        
    
        <li class="first-level "><a href="#context">Context</a></li>
        
    
        <li class="first-level "><a href="#function-fakes">Function Fakes</a></li>
        
            <li class="second-level"><a href="#fake">Fake</a></li>
            
        
            <li class="second-level"><a href="#optional-fake">Optional Fake</a></li>
            
        
            <li class="second-level"><a href="#recorded-fake">Recorded Fake</a></li>
            
        
            <li class="second-level"><a href="#custom-macros">Custom Macros</a></li>
            
        
    
        <li class="first-level "><a href="#fake-configuration">Fake Configuration</a></li>
        
            <li class="second-level"><a href="#helpers">Helpers</a></li>
            
        
    
        <li class="first-level "><a href="#argument-matching">Argument Matching</a></li>
        
            <li class="second-level"><a href="#vector-matcher">Vector Matcher</a></li>
            
        
            <li class="second-level"><a href="#any">any?</a></li>
            
        
    
        <li class="first-level "><a href="#protocol-fakes">Protocol Fakes</a></li>
        
            <li class="second-level"><a href="#syntax">Syntax</a></li>
            
        
            <li class="second-level"><a href="#calls-assertions">Calls &amp; Assertions</a></li>
            
        
            <li class="second-level"><a href="#custom-macros_1">Custom Macros</a></li>
            
        
    
        <li class="first-level "><a href="#assertions">Assertions</a></li>
        
    
        <li class="first-level "><a href="#self-tests">Self-tests</a></li>
        
            <li class="second-level"><a href="#unused-fakes">Unused Fakes</a></li>
            
        
            <li class="second-level"><a href="#unchecked-fakes">Unchecked Fakes</a></li>
            
        
    
        <li class="first-level "><a href="#monkey-patching">Monkey Patching</a></li>
        
    
        <li class="first-level "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="namespaces">Namespaces</h1>
<p>The public API is split into two namespaces:</p>
<ul>
<li><code>clj-fakes.core</code></li>
<li><code>clj-fakes.context</code></li>
</ul>
<p>This is how you could require them in Clojure and ClojureScript:</p>
<pre><code class="clj">; Clojure
(ns unit.example
  (:require
    [clj-fakes.core :as f]
    [clj-fakes.context :as fc]))

; ClojureScript
(ns unit.example
  (:require
    [clj-fakes.core :as f :include-macros true]
    [clj-fakes.context :as fc :include-macros true]))
</code></pre>

<p>These namespaces contain almost the same set of members. The difference 
is that <code>core</code> uses an implicit context and the <code>context</code> namespace
functions require an explicit context argument.</p>
<p>For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. <code>f/any?</code> is the same as <code>fc/any?</code>).</p>
<p>The private/internal API uses a <code>-</code> prefix and should not be used (e.g. <code>-this-is-some-private-thing</code>).</p>
<h1 id="context">Context</h1>
<p>Context is an object which stores all the information about
created fakes (recorded calls, positions in code, etc.).
All fakes have to be created inside some context.</p>
<p>To create a new context use <code>clj-fakes.context/context</code>:</p>
<pre><code class="clj">; explicit context
(let [ctx (fc/context)
      foo (fc/recorded-fake ctx)]
  ; ...
)
</code></pre>

<p>Alternatively a new context can be created with 
<code>clj-fakes.core/with-fakes</code> macro:</p>
<pre><code class="clj">; implicit context
(f/with-fakes
  ; note that now fake is created using a macro from core ns
  (let [foo (f/recorded-fake)]
    ; ...
))
</code></pre>

<p>This approach is preferable since it requires less typing, automatically 
unpatches all <a href="#monkey-patching">patched vars</a> and executes <a href="#self-tests">self-tests</a>.</p>
<p>Internally <code>with-fakes</code> relies on a public dynamic variable <code>*context*</code> which can be 
used in your own helper functions.</p>
<h1 id="function-fakes">Function Fakes</h1>
<p>Fake is a function which returns canned values on matched arguments and can optionally record its calls. It 
can be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).</p>
<h2 id="fake">Fake</h2>
<p>A regular fake function can be created using a macro:</p>
<p><code>(f/fake config)</code></p>
<p><code>(fc/fake ctx config)</code></p>
<p><a href="#fake-configuration">Config</a> is a vector which defines which values to return for different arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;foo&quot;
                   [3 4 5] &quot;bar&quot;])]
  (foo 1 2) ; =&gt; &quot;foo&quot;
  (foo 3 4 5)) ; =&gt; &quot;bar&quot;
</code></pre>

<p>If passed arguments cannot be <a href="#argument-matching">matched</a> using specified 
config then the exception will be raised:</p>
<pre><code class="clj">(foo 100 200) ; =&gt; raises &quot;Unexpected args are passed into fake: (100 200) ...&quot;
</code></pre>

<p>A fake is assumed to be called at least once inside the context; otherwise, <a href="#self-tests">self-test</a> exception 
will be raised. In such case user should either modify a test, an SUT 
or consider using an <a href="#optional-fake">optional fake</a>:</p>
<pre><code class="clj">(f/with-fakes
  (f/fake [[] nil])) ; =&gt; raises &quot;Self-test: no call detected for: non-optional fake ...&quot;
</code></pre>

<p>If your test scenario focuses on testing a behavior (e.g. "assert that foo was called by an SUT") then do not rely on self-tests, 
instead use <a href="#recorded-fake">recorded fakes</a> with explicit <a href="#assertions">assertions</a>. 
Self-tests are more about checking usefulness of provided preconditions than 
about testing expected behavior.</p>
<h2 id="optional-fake">Optional Fake</h2>
<p><code>(f/optional-fake [config])</code></p>
<p><code>(fc/optional-fake ctx [config])</code></p>
<p>It works the same as a regular fake but is not expected to be always called in the context:</p>
<pre><code class="clj">(f/with-fakes
  (f/optional-fake [[1 2] 3])) ; =&gt; ok, self-test will pass
</code></pre>

<p>Such fakes should be used to express the intent of the test writer, 
for example, when you have to provide a dependency to an SUT,
but this dependency is not really related to the test case:</p>
<pre><code class="clj">(defn process-payments
  &quot;Processor requires a logger.&quot;
  [data logger]
  {:pre [(fn? logger)]}
  ; ...
  )

(deftest good-payments-are-processed-without-error
  (f/with-fakes
    (let [; ...
          ; we are not interested in how logger is going to be used, just stub it and forget
          fake-logger (f/optional-fake)]
      (is (= :success (process-payments good-payments fake-logger))))))
</code></pre>

<p>As you may have noticed, <code>config</code> argument can be omitted. 
In such case fake will be created with <a href="#fake-configuration"><code>default-fake-config</code></a> 
which allows any arguments to be passed on invocation.</p>
<h2 id="recorded-fake">Recorded Fake</h2>
<p>Invocations of this fake are recorded so that they can later be asserted:</p>
<p><code>(f/recorded-fake [config])</code></p>
<p><code>(fc/recorded-fake ctx [config])</code></p>
<p>Use <code>calls</code> function in order to get all recorded invocations for the specified 
recorded fake. 
It can also return all the recorded calls in the context if fake is not specified:</p>
<pre><code class="clj">(let [foo (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(+ %1 %2)])
      bar (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(* %1 %2)])]
  (foo 1 2)
  (bar 5 6)
  (foo 7 8)

  (f/calls foo)
  ; =&gt; [{:args [1 2] :return-value 3}
  ;     {:args [7 8] :return-value 15}]

  (f/calls)
  ; =&gt; [[foo {:args [1 2] :return-value 3}]
  ;     [bar {:args [5 6] :return-value 30}]
  ;     [foo {:args [7 8] :return-value 15}]]
)
</code></pre>

<p>Recorded fake must be checked using one of the <a href="#assertions">assertions</a> provided by the framework or
be marked as checked explicitly using <code>mark-checked</code> function; 
otherwise, <a href="#unchecked-fakes">self-test</a> will raise an exception:</p>
<pre><code class="clj">(f/with-fakes
  (f/recorded-fake)) ; =&gt; raises &quot;Self-test: no check performed on: recorded fake ...&quot;
</code></pre>

<pre><code class="clj">(f/with-fakes
  (let [foo (f/recorded-fake)]
    (foo)
    (f/was-called foo []))) ; =&gt; ok, self-test will pass
</code></pre>

<pre><code class="clj">(f/with-fakes
  (f/mark-checked (f/recorded-fake))) ; =&gt; ok, self-test will pass
</code></pre>

<h2 id="custom-macros">Custom Macros</h2>
<p>In your own reusable macros you should use <code>fake*/recorded-fake*</code> 
instead of <code>fake/recorded-fake</code>:</p>
<p><code>(f/fake* form config)</code></p>
<p><code>(fc/fake* ctx form config)</code></p>
<p><code>(f/recorded-fake* form [config])</code></p>
<p><code>(fc/recorded-fake* ctx form [config])</code></p>
<p>In other words, your macro must explicitly provide <code>&amp;form</code> to framework macros; 
otherwise, due to implementation details, framework will not be 
able to correctly determine fake function line numbers which is crucial for debugging. </p>
<p>The framework will warn you if you accidentally use the version without asterisk 
in your macro.</p>
<h1 id="fake-configuration">Fake Configuration</h1>
<p>Fake config should contain pairs of <a href="#argument-matchinga">args matcher</a> and return value:</p>
<pre><code class="clj">[args-matcher1 fn-or-value1
args-matcher2 fn-or-value2 ...]
</code></pre>

<p>On fake invocation matchers will be tested from top to bottom and 
on the first match the specified value will be returned. 
If return value is a function than it will be called with passed arguments to generate the return value at runtime:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] 100
                   [3 4] #(+ %1 %2)
                   [5 6] (fn [_ _] (throw (ex-info &quot;wow&quot; {})))])]
  (foo 1 2) ; =&gt; 100
  (foo 3 4) ; =&gt; 7
  (foo 5 6)) ; =&gt; raises &quot;wow&quot; exception
</code></pre>

<p>There's one built-in config in the framework:</p>
<p><code>fc/default-fake-config</code></p>
<p>It accepts any number of arguments and returns a new unique 
instance of type <code>FakeReturnValue</code> on each call.
It is used by <code>optional-fake</code> and <code>recorded-fake</code> functions by default (i.e. when user 
doesn't specify the config explicitly).</p>
<h2 id="helpers">Helpers</h2>
<p><code>(f/cyclically coll)</code></p>
<p><code>(fc/cyclically coll)</code></p>
<p>This function can be used to implement iterator-style stubbing 
when a fake returns a different value on each call:</p>
<pre><code class="clj">(let [get-weekday (f/fake [[&quot;My event&quot;] (f/cyclically [:monday :tuesday :wednesday])])]
  (is (= :monday (get-weekday &quot;My event&quot;)))
  (is (= :tuesday (get-weekday &quot;My event&quot;)))
  (is (= :wednesday (get-weekday &quot;My event&quot;)))
  (is (= :monday (get-weekday &quot;My event&quot;))))
</code></pre>

<h1 id="argument-matching">Argument Matching</h1>
<p>Every arguments matcher must implement an <code>fc/ArgsMatcher</code> protocol:</p>
<pre><code class="clj">(defprotocol ArgsMatcher
  (args-match? [this args] &quot;Should return true or false.&quot;)
  (args-matcher-&gt;str [this] &quot;Should return a string for debug messages.&quot;))
</code></pre>

<p>In most cases you won't need to create instances of this protocol manually 
because framework provides vector matchers which are useful in most cases.</p>
<h2 id="vector-matcher">Vector Matcher</h2>
<p>Vector matchers were already used all other this guide. 
Each vector element can be an expected value or an <code>fc/ImplicitArgMatcher</code> instance:</p>
<pre><code class="clj">[implicit-arg-matcher-or-exact-value1 implicit-arg-matcher-or-exact-value2 ...]
</code></pre>

<pre><code class="clj">(defprotocol ImplicitArgMatcher
  (arg-matches-implicitly? [this arg] &quot;Should return true or false.&quot;)
  (arg-matcher-&gt;str [this] &quot;Should return a string for debug messages.&quot;))
</code></pre>

<p>It is not recommended to extend existing types with <code>ImplicitArgMatcher</code> protocol; 
instead, to make code more explicit and future-proof, 
you should use an <code>arg</code> "adapter" macro and pass it <code>ArgMatcher</code> instances:</p>
<pre><code class="clj">(let [foo (f/fake [[] &quot;no args&quot;
                   [[]] &quot;empty vector&quot;
                   [1 2] &quot;1 2&quot;
                   [(f/arg integer?) (f/arg integer?)] &quot;two integers&quot;
                   [(f/arg string?)] &quot;string&quot;])]
  (foo) ; =&gt; &quot;no args&quot;
  (foo []) ; =&gt; &quot;empty vector&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; exception: &quot;Unexpected args are passed into fake: (1 2 3) ...&quot;
  (foo 100 200) ; =&gt; &quot;two integers&quot;
  (foo &quot;hey&quot;)) ; =&gt; &quot;string&quot;
</code></pre>

<p>As you can see, the framework already supports <em>functional argument matchers</em> 
which are implemented by extending function type like this:</p>
<pre><code class="clj">(extend-type #?(:clj  clojure.lang.Fn
                :cljs function)
  ArgMatcher
  (arg-matches? [this arg]
    (this arg)))
</code></pre>

<p>You are encouraged to define your own argument matchers in a similar way.</p>
<p>The framework also supports <em>regex matchers</em> (using 
<a href="https://clojuredocs.org/clojure.core/re-find"><code>re-find</code></a> under the hood), for example: <code>(f/arg #"abc.*")</code>.</p>
<h2 id="any">any?</h2>
<p><code>(f/any? _)</code></p>
<p><code>(fc/any? _)</code></p>
<p>This special matcher always returns <code>true</code> for any input arguments. 
It can be used to match single and multiple arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;1 2&quot;
                   [f/any? f/any? f/any?] &quot;three args&quot;
                   f/any? &quot;something else&quot;])]
  (foo) ; =&gt; &quot;something else&quot;
  (foo 1) ; =&gt; &quot;something else&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; &quot;three args&quot;
  (foo 1 2 3 4)) ; =&gt; &quot;something else&quot;
</code></pre>

<h1 id="protocol-fakes">Protocol Fakes</h1>
<p>Framework defines two new macros for reifying protocols 
using function fakes described earlier. So, for example, 
you can record and assert method calls on reified instances.</p>
<p>The "strict" <code>reify-fake</code> macro is very similar to <code>reify</code>; in particular, 
created instance will raise an exception 
on calling protocol method which is not defined. </p>
<p>On the other hand, <code>reify-nice-fake</code> is able to automatically 
generate <a href="#optional-fake">optional-fake</a> implementations for methods which are 
not explicitly defined by user. </p>
<p>Which macro to use solely depends on your testing style. I'd 
recommend to use nice fakes whenever possible in order to make 
tests more compact and break less often on code changes.</p>
<p>There are some subtleties, so here's a table to give you an overview of 
which features are currently supported:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>reify-fake</code></th>
<th><code>reify-nice-fake</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Fake protocol method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Object method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake protocol method (auto)</td>
<td>-</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (auto)</td>
<td>-</td>
<td>No</td>
</tr>
<tr>
<td>Fake Object method (auto)</td>
<td>-</td>
<td>No</td>
</tr>
<tr>
<td>Support overloaded methods</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Object can be reified with any new methods</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="syntax">Syntax</h2>
<p>The syntax is very similar to the built-in <code>reify</code> macro:</p>
<p><code>(f/reify-fake specs*)</code></p>
<p><code>(fc/reify-fake ctx specs*)</code></p>
<p><code>(f/reify-nice-fake specs*)</code></p>
<p><code>(fc/reify-nice-fake ctx specs*)</code></p>
<p>Each spec consists of the protocol or interface name followed by zero
or more method fakes:</p>
<pre><code class="clj">protocol-or-interface-or-Object
(method-name fake-type config)*
</code></pre>

<p>Available fake types:</p>
<ul>
<li><code>:fake</code> (see <a href="#fake">Fake</a>)</li>
<li><code>:optional-fake</code> (see <a href="#optional-fake">Optional Fake</a>)</li>
<li><code>:recorded-fake</code> (see <a href="#recorded-fake">Recorded Fake</a>)</li>
</ul>
<p>As with function fakes, config can be omitted for <code>:optional-fake</code> and <code>:recorded-fake</code>:</p>
<pre><code class="clj">(defprotocol AnimalProtocol
  (speak [this] [this name] [this name1 name2])
  (eat [this food drink])
  (sleep [this]))

(defprotocol FileProtocol
  (save [this])
  (scan [this]))

; ...

(f/reify-fake
  p/AnimalProtocol
  (sleep :fake [f/any? &quot;zzz&quot;])
  (speak :recorded-fake)

  p/FileProtocol
  (save :optional-fake)

  java.lang.CharSequence
  (charAt :recorded-fake [f/any? \a]))
</code></pre>

<p>Although protocol methods always have a first <code>this</code> argument, 
method configs must not try to match this argument. 
However, the return value function will receive all the arguments on invocation, 
including <code>this</code>:</p>
<pre><code class="clj">(let [monkey (f/reify-fake p/AnimalProtocol
                           ; config only matches |food| and |drink| arguments
                           ; but return value function will get all 3 arguments on call
                           (eat :fake [[f/any? f/any?] #(str &quot;ate &quot; %2 &quot; and drank &quot; %3)]))]
      (println (p/eat monkey &quot;banana&quot; &quot;water&quot;))) ; =&gt; ate banana and drank water
</code></pre>

<h2 id="calls-assertions">Calls &amp; Assertions</h2>
<p>In order to get and assert recorded method calls there's a 
helper function:</p>
<p><code>(f/method obj f)</code></p>
<p><code>(fc/method ctx obj f)</code></p>
<p>It can be used in combination with existing <code>calls</code> and <code>was-called-*</code> functions like this:</p>
<pre><code class="clj">(f/with-fakes
  (let [cow (f/reify-fake p/AnimalProtocol
                          (speak :recorded-fake [f/any? &quot;moo&quot;]))]
    (p/speak cow)
    (println (f/calls (f/method cow p/speak))) ; =&gt; [{:args ..., :return-value moo}]
    (is (f/was-called-once (f/method cow p/speak) [cow]))))
</code></pre>

<p>Notice how object name <code>cow</code> is duplicated at the last line. In order to get 
rid of such duplications there are additional <code>method-*</code> assertions defined. 
So the last expression can be rewritten like this:</p>
<pre><code class="clj">(is (f/method-was-called-once p/speak cow []))
</code></pre>

<p>For the list of all available assertion functions see <a href="#assertions">Assertions</a>.</p>
<p>There's a quirk when Java interface method is faked: you will need to use its
string representation in <code>method</code>/<code>method-*</code>:</p>
<pre><code class="clj">(let [foo (f/reify-fake clojure.lang.IFn
                        (invoke :recorded-fake))]
  (foo 1 2 3)
  (is (f/method-was-called &quot;invoke&quot; foo [1 2 3])))
</code></pre>

<h2 id="custom-macros_1">Custom Macros</h2>
<p>In your own reusable macros you should use <code>reify-fake*/reify-nice-fake*</code> 
instead of <code>reify-fake/reify-nice-fake</code>:</p>
<p><code>(f/reify-fake* form env specs*)</code></p>
<p><code>(fc/reify-fake* ctx form env specs*)</code></p>
<p><code>(f/reify-nice-fake* form env specs*)</code></p>
<p><code>(fc/reify-nice-fake* ctx form env specs*)</code></p>
<p>In other words, your macro must explicitly provide <code>&amp;form</code> and <code>&amp;env</code> to framework macros; 
otherwise, due to implementation details, framework will not be 
able to correctly determine fake method line numbers which is crucial for debugging. </p>
<p>For instance:</p>
<pre><code class="clj">(defmacro my-reify-fake
  [&amp; specs]
  `(f/reify-fake* ~&amp;form ~&amp;env ~@specs))
</code></pre>

<p>The framework will warn you if you accidentally use the version without asterisk 
in your macro.</p>
<h1 id="assertions">Assertions</h1>
<p>Framework provides several assertion functions for <a href="#recorded-fake">recorded fakes</a>. 
Each function either returns <code>true</code> or raises an exception with additional details:</p>
<p><code>(f/was-called-once f args-matcher)</code>
- checks that function was called strictly once and that the call was with the specified args.</p>
<p><code>(f/was-called f args-matcher)</code>
- checks that function was called at least once with the specified args.</p>
<p><code>(f/was-not-called f)</code>
- checks that function was never called.</p>
<p><code>(f/were-called-in-order f1 args-matcher1 f2 args-matcher2 ...)</code>
- checks that functions were called in specified order (but it doesn't guarantee there were no other calls).</p>
<p>The set of similar functions is defined for <a href="#calls-assertions">protocol methods</a>:</p>
<p><code>(f/method-was-called-once f obj args-matcher)</code></p>
<p><code>(f/method-was-called f obj args-matcher)</code></p>
<p><code>(f/method-was-not-called f obj)</code></p>
<p><code>(f/methods-were-called-in-order f1 obj1 args-matcher1 f2 obj2 args-matcher2 ...)</code></p>
<p>Of course, all these functions can be called with an explicit context:</p>
<p><code>(fc/was-called-once ctx f args-matcher)</code></p>
<p><code>(fc/was-called ctx f args-matcher)</code></p>
<p><code>(fc/was-not-called ctx f)</code></p>
<p><code>(fc/were-called-in-order ctx f1 args-matcher1 f2 args-matcher2 ...)</code></p>
<p><code>(fc/method-was-called-once ctx f obj args-matcher)</code></p>
<p><code>(fc/method-was-called ctx f obj args-matcher)</code></p>
<p><code>(fc/method-was-not-called ctx f obj)</code></p>
<p><code>(fc/methods-were-called-in-order ctx f1 obj1 args-matcher1 f2 obj2 args-matcher2 ...)</code></p>
<h1 id="self-tests">Self-tests</h1>
<p>Framework can perform "self-tests" in order to inform a user 
early on that some fakes (including protocol method fakes) are potentially used inappropriately.</p>
<p>If you use <a href="#context"><code>with-fakes</code></a> macro then self-tests will be run automatically on exiting the block.
Otherwise, when <a href="#context">explicit context</a> is used, you have to invoke self-tests manually.</p>
<p>Currently two types of self-tests are supported to identify:</p>
<ul>
<li>unused fakes </li>
<li>unchecked fakes</li>
</ul>
<h2 id="unused-fakes">Unused Fakes</h2>
<p><code>(fc/self-test-unused-fakes ctx)</code></p>
<p>This function raises an exception when some <a href="#fake">fake</a> was never called after its creation.</p>
<p>For example, this self-test comes in handy when SUT stops using a dependency which 
was faked in several test scenarios. In such case the framework will guide you in cleaning 
 your test suite from the unused stubs.</p>
<h2 id="unchecked-fakes">Unchecked Fakes</h2>
<p><code>(fc/self-test-unchecked-fakes ctx)</code></p>
<p>This self-test raises an exception if some <code>recorded-fake</code> 
was never <a href="#recorded-fake">marked checked</a>, i.e. you forgot to assert its calls.</p>
<h1 id="monkey-patching">Monkey Patching</h1>
<p>You can temporarily change a variable value by using <code>patch!</code> macro:</p>
<p><code>(f/patch! var-expr val)</code></p>
<p><code>(fc/patch! ctx var-expr val)</code></p>
<p>After patching original value can still be obtained using a function:</p>
<p><code>(f/original-val a-var)</code></p>
<p><code>(fc/original-val ctx a-var)</code></p>
<p>Also don't forget to unpatch the variable to recover its original value:</p>
<p><code>(f/unpatch! var-expr)</code></p>
<p><code>(fc/unpatch! ctx var-expr)</code></p>
<p>Or unpatch all the variables inside the context at once:</p>
<p><code>(f/unpatch-all!)</code></p>
<p><code>(fc/unpatch-all! ctx)</code></p>
<p>If you use <code>with-fakes</code> then all variables will be unpatched 
automatically on exiting the block, for instance:</p>
<pre><code class="clj">(f/with-fakes
  (f/patch! #'funcs/sum (f/fake [[1 2] &quot;foo&quot;
                                 [3 4] &quot;bar&quot;]))
  (is (= &quot;foo&quot; (funcs/sum 1 2)))
  (is (= &quot;bar&quot; (funcs/sum 3 4))))

; patching is reverted on exiting with-fakes block
(is (= 3 (funcs/sum 1 2)))
</code></pre>

<p>Another example is combining <code>patch</code> and <code>recorded-fake</code> in order
to create a <em>function spy</em> which works exactly the same as the original function
and also records its calls:</p>
<pre><code class="clj">(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))
</code></pre>

<p>Monkey patching is not thread-safe because it changes variable 
in all threads 
(underlying implementation uses 
<a href="https://clojuredocs.org/clojure.core/alter-var-root"><code>alter-var-root</code></a>/<a href="https://github.com/cljsinfo/cljs-api-docs/blob/catalog/refs/special/setBANG.md"><code>set!</code></a>).</p>
<p>Starting from Clojure 1.8, if <a href="http://clojure.org/reference/compilation#directlinking">direct linking</a> is enabled:</p>
<ul>
<li>you have to add <code>^:redef</code> metadata key to functions which you patch;</li>
<li>you can't patch core functions (e.g. <code>println</code>).</li>
</ul>
<h1 id="references">References</h1>
<p>The API was mainly inspired by <a href="http://www.jmock.org/">jMock</a> and 
<a href="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</a> frameworks with
design decisions loosely based on the 
<a href="http://osherove.com/blog/2013/11/23/fifteen-things-i-look-for-in-an-isolation-framework.html">"Fifteen things I look for in an Isolation framework" by Roy Osherove</a>.</p>
<p>Some alternative frameworks with isolation capabilities:</p>
<ul>
<li><a href="https://github.com/bguthrie/shrubbery">shrubbery</a></li>
<li><a href="https://github.com/EchoTeam/clj-mock">clj-mock</a></li>
<li><a href="https://github.com/amitrathore/conjure">conjure</a></li>
<li><a href="https://github.com/marick/Midje">Midje</a></li>
<li><a href="https://github.com/slagyr/speclj">speclj</a></li>
</ul>
<p>Also take at look at the article 
<a href="http://blog.josephwilk.net/clojure/isolating-external-dependencies-in-clojure.html">"Isolating External Dependencies in Clojure" by Joseph Wilk</a>.</p>
<p>For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:</p>
<ul>
<li>"Test Driven Development: By Example" by Kent Beck</li>
<li>"Growing Object-Oriented Software, Guided by Tests" by Steve Freeman and Nat Pryce [<a href="http://www.growing-object-oriented-software.com/">site</a>]</li>
<li>"xUnit Test Patterns: Refactoring Test Code" by Gerard Meszaros [<a href="http://xunitpatterns.com/">site</a>]</li>
</ul></div>
        
    </div>

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
    </footer>

    <script src="../js/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '..';
    </script>
    <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
    <script src="../js/base.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
