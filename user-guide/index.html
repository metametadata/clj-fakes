<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>User Guide - clj-fakes</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">clj-fakes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">User Guide</a>
                </li>
            
            
            
                <li >
                    <a href="../dev-guide/">Developer Guide</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../dev-guide/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/metametadata/clj-fakes/">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#namespaces">Namespaces</a></li>
        
    
        <li class="main "><a href="#context">Context</a></li>
        
    
        <li class="main "><a href="#function-fakes">Function Fakes</a></li>
        
            <li><a href="#fake">Fake</a></li>
        
            <li><a href="#optional-fake">Optional Fake</a></li>
        
            <li><a href="#recorded-fake">Recorded Fake</a></li>
        
            <li><a href="#custom-macros">Custom Macros</a></li>
        
    
        <li class="main "><a href="#fake-configuration">Fake Configuration</a></li>
        
    
        <li class="main "><a href="#argument-matching">Argument Matching</a></li>
        
            <li><a href="#built-in-matchers">Built-in matchers</a></li>
        
    
        <li class="main "><a href="#protocol-fakes">Protocol Fakes</a></li>
        
            <li><a href="#syntax">Syntax</a></li>
        
            <li><a href="#calls-assertions">Calls &amp; Assertions</a></li>
        
            <li><a href="#custom-macros_1">Custom Macros</a></li>
        
    
        <li class="main "><a href="#assertions">Assertions</a></li>
        
    
        <li class="main "><a href="#self-tests">Self-tests</a></li>
        
            <li><a href="#unused-fakes">Unused Fakes</a></li>
        
            <li><a href="#unchecked-fakes">Unchecked Fakes</a></li>
        
    
        <li class="main "><a href="#monkey-patching">Monkey Patching</a></li>
        
    
        <li class="main "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="namespaces">Namespaces</h1>
<p>The public API is split into two namespaces:</p>
<ul>
<li><code>clj-fakes.core</code></li>
<li><code>clj-fakes.context</code></li>
</ul>
<p>This is how you could require them in Clojure and ClojureScript:</p>
<pre><code class="clj">; Clojure
(ns unit.example
  (:require
    [clj-fakes.core :as f]
    [clj-fakes.context :as fc]))

; ClojureScript
(ns unit.example
  (:require
    [clj-fakes.core :as f :include-macros true]
    [clj-fakes.context :as fc :include-macros true]))
</code></pre>

<p>These namespaces contain almost the same set of members. The difference 
is that <code>core</code> uses an implicit context and the <code>context</code> namespace
functions require an explicit context argument.</p>
<p>For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. <code>f/any?</code> is the same as <code>fc/any?</code>).</p>
<p>The private/internal API uses a <code>-</code> prefix and should not be used (e.g. <code>-this-is-some-private-thing</code>).</p>
<h1 id="context">Context</h1>
<p>Context is an object which stores all the information about
created fakes (recorded calls, positions in code, etc.).
All fakes have to be created inside some context.</p>
<p>To create a new context use <code>clj-fakes.context/context</code>:</p>
<pre><code class="clj">; explicit context
(let [ctx (fc/context)
      foo (fc/recorded-fake ctx)]
  ; ...
)
</code></pre>

<p>Alternatively a new context can be created with 
<code>clj-fakes.core/with-fakes</code> macro:</p>
<pre><code class="clj">; implicit context
(f/with-fakes
  ; note that now fake is created using a macro from core ns
  (let [foo (f/recorded-fake)]
    ; ...
))
</code></pre>

<p>This approach is preferable since it requires less typing, automatically 
unpatches all <a href="#monkey-patching">patched vars</a> and executes <a href="#self-tests">self-tests</a>.</p>
<p>Internally <code>with-fakes</code> relies on a public dynamic variable <code>*context*</code> which can be 
used in your own helper functions.</p>
<h1 id="function-fakes">Function Fakes</h1>
<p>Fake is a function which returns canned values on matched arguments and can optionally record its calls. It 
can be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).</p>
<h2 id="fake">Fake</h2>
<p>A regular fake function can be created using a macro:</p>
<p><code>(f/fake config)</code></p>
<p><code>(fc/fake ctx config)</code></p>
<p><a href="#fake-configuration">Config</a> is a vector which defines which values to return for different arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;foo&quot;
                   [3 4 5] &quot;bar&quot;])]
  (foo 1 2) ; =&gt; &quot;foo&quot;
  (foo 3 4 5)) ; =&gt; &quot;bar&quot;
</code></pre>

<p>If passed arguments cannot be <a href="#argument-matching">matched</a> using specified 
config then the exception will be raised:</p>
<pre><code class="clj">(foo 100 200) ; =&gt; raises &quot;Unexpected args are passed into fake: (100 200)&quot;
</code></pre>

<p>A fake is assumed to be called at least once inside the context; otherwise, <a href="#self-tests">self-test</a> exception 
will be raised. In such case user should either modify a test, an SUT 
or consider using an <a href="#optional-fake">optional fake</a>:</p>
<pre><code class="clj">(f/with-fakes
  (f/fake [[] nil])) ; =&gt; raises &quot;Self-test: no call detected for: non-optional fake ...&quot;
</code></pre>

<p>If your test scenario focuses on testing a behavior (e.g. "assert that foo was called by an SUT") then do not rely on self-tests, 
instead use <a href="#recorded-fake">recorded fakes</a> with explicit assertions. 
Self-tests are more about checking usefulness of provided preconditions than 
about testing expected behavior.</p>
<h2 id="optional-fake">Optional Fake</h2>
<p><code>(f/optional-fake [config])</code></p>
<p><code>(fc/optional-fake ctx [config])</code></p>
<p>It works the same as a regular fake but is not expected to be always called in the context:</p>
<pre><code class="clj">(f/with-fakes
  (f/optional-fake [[1 2] 3])) ; =&gt; ok, self-test will pass
</code></pre>

<p>Such fakes should be used to express the intent of the test writer, 
for example, when you have to provide a dependency to an SUT,
but this dependency is not really related to the test case:</p>
<pre><code class="clj">(defn process-payments
  &quot;Processor requires a logger.&quot;
  [data logger]
  {:pre [(fn? logger)]}
  ; ...
  )

(deftest good-payments-are-processed-without-error
  (f/with-fakes
    (let [; ...
          ; we are not interested in how logger is going to be used, just stub it and forget
          fake-logger (f/optional-fake)]
      (is (= :success (process-payments good-payments fake-logger))))))
</code></pre>

<p>As you may have noticed, <code>config</code> argument can be omitted. 
In such case fake will be created with <a href="#fake-configuration"><code>(default-fake-config)</code></a> 
which allows any arguments to be passed on invocation.</p>
<h2 id="recorded-fake">Recorded Fake</h2>
<p>Invocations of this fake are recorded so that they can later be asserted:</p>
<p><code>(f/recorded-fake [config])</code></p>
<p><code>(fc/recorded-fake ctx [config])</code></p>
<p>Use <code>calls</code> function in order to get all recorded invocations for the specified 
recorded fake. 
It can also return all the recorded calls in the context if fake is not specified:</p>
<pre><code class="clj">(let [foo (f/recorded-fake [[integer? integer?] #(+ %1 %2)])
      bar (f/recorded-fake [[integer? integer?] #(* %1 %2)])]
  (foo 1 2)
  (bar 5 6)
  (foo 7 8)

  (f/calls foo)
  ; =&gt; [{:args [1 2] :return-value 3}
  ;     {:args [7 8] :return-value 15}]

  (f/calls)
  ; =&gt; [[foo {:args [1 2] :return-value 3}]
  ;     [bar {:args [5 6] :return-value 30}]
  ;     [foo {:args [7 8] :return-value 15}]]
)
</code></pre>

<p>Recorded fake must be checked using one of the <a href="#assertions">assertions</a> provided by the framework or
be marked as checked explicitly using <code>mark-checked</code> function; otherwise, self-test will raise an exception:</p>
<pre><code class="clj">(f/with-fakes
  (f/recorded-fake)) ; =&gt; raises &quot;Self-test: no check performed on: recorded fake ...&quot;
</code></pre>

<pre><code class="clj">(f/with-fakes
  (let [foo (f/recorded-fake)]
    (f/was-called foo))) ; =&gt; ok, self-test will pass
</code></pre>

<pre><code class="clj">(f/with-fakes
  (f/mark-checked (f/recorded-fake))) ; =&gt; ok, self-test will pass
</code></pre>

<h2 id="custom-macros">Custom Macros</h2>
<p>In your own reusable macros you should use <code>fake*/recorded-fake*</code> 
instead of <code>fake/recorded-fake</code>:</p>
<p><code>(f/fake* form config)</code></p>
<p><code>(fc/fake* ctx form config)</code></p>
<p><code>(f/recorded-fake* form [config])</code></p>
<p><code>(fc/recorded-fake* ctx form [config])</code></p>
<p>In other words, your macro must explicitly provide <code>&amp;form</code> to framework macros; 
otherwise, due to implementation details, framework will not be 
able to correctly determine fake function line numbers which is crucial for debugging. </p>
<p>The framework will warn you if you accidentally use the version without asterisk 
in your macro.</p>
<h1 id="fake-configuration">Fake Configuration</h1>
<p>Fake config should contain pairs of argument matcher and return value:</p>
<pre><code class="clj">[args-matcher1 fn-or-value1
args-matcher2 fn-or-value2 ...]
</code></pre>

<p>On fake invocation argument matchers will be tested from top to bottom and 
on the first match the specified value will be returned. If return value is a function than it will be called with passed arguments to generate the return value at runtime:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] 100
                   [3 4] #(+ %1 %2)])]
  (foo 1 2) ; =&gt; 100
  (foo 3 4)) ; =&gt; 7
</code></pre>

<p>There's one built-in config in the framework:</p>
<p><code>fc/default-fake-config</code></p>
<p>It accepts any number of arguments and returns a new unique 
instance of protocol <code>fc/FakeReturnValue</code> on each call.
It is used by <code>optional-fake</code> and <code>recorded-fake</code> functions by default (i.e. when user 
doesn't specify the config explicitly).</p>
<h1 id="argument-matching">Argument Matching</h1>
<p>Argument matcher must implement an <code>fc/ArgsMatcher</code> protocol:</p>
<pre><code class="clj">(defprotocol ArgsMatcher
  (args-match? [this args] &quot;Should return true or false.&quot;))
</code></pre>

<p>In most cases you won't need to create instances of this protocol manually 
because framework provides functional and vector matchers which are useful in most cases.</p>
<h2 id="built-in-matchers">Built-in matchers</h2>
<h3 id="functional-matcher">Functional matcher</h3>
<p>Functional matcher is a function which takes a vector of call arguments and returns true/false. 
Example:</p>
<pre><code class="clj">(let [foo (f/fake [#(odd? (count %)) &quot;odd number of args&quot;
                   #(even? (count %)) &quot;even number of args&quot;])]
  (foo 1 2) ; =&gt; &quot;even number of args&quot;
  (foo 1 2 3)) ; =&gt; &quot;odd number of args&quot;
</code></pre>

<p>It's actually implemented like this:</p>
<pre><code class="clj">(extend-type #?(:clj  clojure.lang.Fn
                :cljs function)
  ArgsMatcher
  (args-match? [this args]
    (this args)))
</code></pre>

<h3 id="vector-matcher">Vector matcher</h3>
<p>Vector matchers were already used all other this guide, they looks like this:</p>
<pre><code class="clj">[value-or-function1 value-or-function2 ...]
</code></pre>

<p>Let's look at the demo:</p>
<pre><code class="clj">(let [foo (f/fake [[] &quot;no args&quot;
                   [[]] &quot;empty vector&quot;
                   [1 2] &quot;1 2&quot;
                   [integer?] &quot;integer&quot;
                   [str?] &quot;string&quot;])]
  (foo) ; =&gt; &quot;no args&quot;
  (foo []) ; =&gt; &quot;empty vector&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; exception: &quot;Unexpected args are passed into fake: (1 2 3)&quot;
  (foo 123) ; =&gt; &quot;integer&quot;
  (foo &quot;hey&quot;)) ; =&gt; &quot;string&quot;
</code></pre>

<h3 id="any">any?</h3>
<p><code>(f/any? args)</code>
<code>(fc/any? args)</code></p>
<p>This matcher always returns <code>true</code> for any input arguments:</p>
<pre><code class="clj">(let [foo (f/fake [[1 2] &quot;1 2&quot;
                   [f/any? f/any? f/any?] &quot;three args&quot;
                   f/any? &quot;something else&quot;])]
  (foo) ; =&gt; &quot;something else&quot;
  (foo 1) ; =&gt; &quot;something else&quot;
  (foo 1 2) ; =&gt; &quot;1 2&quot;
  (foo 1 2 3) ; =&gt; &quot;three args&quot;
  (foo 1 2 3 4)) ; =&gt; &quot;something else&quot;
</code></pre>

<h1 id="protocol-fakes">Protocol Fakes</h1>
<p>Framework defines two new macros for reifying protocols 
using function fakes described earlier. So, for example, 
you can record and assert method calls on reified instances.</p>
<p>The "strict" <code>reify-fake</code> macro is very similar to <code>reify</code>; in particular, 
created instance will raise an exception 
on calling protocol method which is not defined. </p>
<p>On the other hand, <code>reify-nice-fake</code> is able to automatically 
generate <a href="#optional-fake">optional-fake</a> implementations for methods which are 
not explicitly defined by user. </p>
<p>Which macro to use solely depends on your testing style. I'd 
recommend to use nice fakes whenever possible in order to make 
tests more compact and break less often on code changes.</p>
<p>There are some subtleties, so here's a table to give you an overview of 
which features are currently supported:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>reify-fake</code></th>
<th><code>reify-nice-fake</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Fake protocol method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake protocol method (auto)</td>
<td>-</td>
<td>Yes</td>
</tr>
<tr>
<td>Support overloaded protocol methods</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Java interface method (auto)</td>
<td>-</td>
<td>No</td>
</tr>
<tr>
<td>Fake Object method (explicitly)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fake Object method (auto)</td>
<td>-</td>
<td>No</td>
</tr>
<tr>
<td>Object can be reified with any new methods</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="syntax">Syntax</h2>
<p>The syntax is very similar to the built-in <code>reify</code> macro:</p>
<p><code>(f/reify-fake specs*)</code></p>
<p><code>(fc/reify-fake ctx specs*)</code></p>
<p><code>(f/reify-nice-fake specs*)</code></p>
<p><code>(fc/reify-nice-fake ctx specs*)</code></p>
<p>Each spec consists of the protocol or interface name followed by zero
or more method fakes:</p>
<pre><code class="clj">protocol-or-interface-or-Object
(method-name fake-type config)*
</code></pre>

<p>Available fake types:</p>
<ul>
<li><code>:fake</code></li>
<li><code>:optional-fake</code></li>
<li><code>:recorded-fake</code></li>
</ul>
<p>As with function fakes, config can be omitted for <code>:optional-fake</code> and <code>:recorded-fake</code>:</p>
<pre><code class="clj">(defprotocol AnimalProtocol
  (speak [this] [this name] [this name1 name2])
  (eat [this food drink])
  (sleep [this]))

(defprotocol FileProtocol
  (save [this])
  (scan [this]))

; ...

(f/reify-fake
  p/AnimalProtocol
  (sleep :fake [f/any? &quot;zzz&quot;])
  (speak :recorded-fake)

  p/FileProtocol
  (save :optional-fake)

  java.lang.CharSequence
  (charAt :recorded-fake [f/any? \a]))
</code></pre>

<p>While protocol methods always have a first <code>this</code> argument, 
method config must not try to match this argument (there is no sense to do it).
However, the return value function will receive all the arguments on invocation, 
including <code>this</code>:</p>
<pre><code class="clj">(let [monkey (f/reify-fake p/AnimalProtocol
                           ; config only matches |food| and |drink| arguments
                           ; but return value function will get all 3 arguments on call
                           (eat :fake [[f/any? f/any?] #(str &quot;ate &quot; %2 &quot; and drank &quot; %3)]))]
      (println (p/eat monkey &quot;banana&quot; &quot;water&quot;))) ; =&gt; ate banana and drank water
</code></pre>

<h2 id="calls-assertions">Calls &amp; Assertions</h2>
<p>In order to get and assert recorded method calls there's a 
helper function:</p>
<p><code>(f/method obj f)</code></p>
<p><code>(fc/method ctx obj f)</code></p>
<p>It can be used in combination with existing <code>calls</code> and <code>was-called-*</code> functions like this:</p>
<pre><code class="clj">(f/with-fakes
  (let [cow (f/reify-fake p/AnimalProtocol
                          (speak :recorded-fake [f/any? &quot;moo&quot;]))]
    (p/speak cow)
    (println (f/calls (f/method cow p/speak))) ; =&gt; [{:args ..., :return-value moo}]
    (is (f/was-called (f/method cow p/speak) [cow]))))
</code></pre>

<p>Notice how object name <code>cow</code> is duplicated at the last line. In order to get 
rid of such duplications there are additional <code>was-called-*-on</code> functions defined. 
So the last expression can be rewritten like this:</p>
<pre><code class="clj">(is (f/was-called-on cow p/speak))
</code></pre>

<p>For the list of all available assertion functions see <a href="#assertions">Assertions</a>.</p>
<h2 id="custom-macros_1">Custom Macros</h2>
<p>In your own reusable macros you should use <code>reify-fake*/reify-nice-fake*</code> 
instead of <code>reify-fake/reify-nice-fake</code>:</p>
<p><code>(f/reify-fake* form env specs*)</code></p>
<p><code>(fc/reify-fake* ctx form env specs*)</code></p>
<p><code>(f/reify-nice-fake* form env specs*)</code></p>
<p><code>(fc/reify-nice-fake* ctx form env specs*)</code></p>
<p>In other words, your macro must explicitly provide <code>&amp;form</code> and <code>&amp;env</code> to framework macros; 
otherwise, due to implementation details, framework will not be 
able to correctly determine fake method line numbers which is crucial for debugging. </p>
<p>For instance:</p>
<pre><code class="clj">(defmacro my-reify-fake
  [&amp; specs]
  `(f/reify-fake* ~&amp;form ~&amp;env ~@specs))
</code></pre>

<p>The framework will warn you if you accidentally use the version without asterisk 
in your macro.</p>
<h1 id="assertions">Assertions</h1>
<p>Framework provides several assertion functions for <a href="#recorded-fake">recorded fakes</a>. 
Each function either returns <code>true</code> or raises an exception with additional details:</p>
<p><code>(f/was-called-once f [args-matcher])</code>
- checks that function was called strictly once and that the call was with the specified args.</p>
<p><code>(f/was-called f [args-matcher])</code>
- checks that function was called at least once with the specified args.</p>
<p><code>(f/was-not-called f)</code>
- checks that function was never called.</p>
<p>The set of similar functions is defined for <a href="#calls-assertions">protocol methods</a>:</p>
<p><code>(f/was-called-once-on obj f [args-matcher])</code></p>
<p><code>(f/was-called-on obj f [args-matcher])</code></p>
<p><code>(f/was-not-called-on obj f)</code></p>
<p>Of course, all these functions can be called with an explicit context:</p>
<p><code>(fc/was-called-once ctx f [args-matcher])</code></p>
<p><code>(fc/was-called ctx f [args-matcher])</code></p>
<p><code>(fc/was-not-called ctx f)</code></p>
<p><code>(fc/was-called-once-on ctx obj f [args-matcher])</code></p>
<p><code>(fc/was-called-on obj ctx f [args-matcher])</code></p>
<p><code>(fc/was-not-called-on ctx obj f)</code></p>
<h1 id="self-tests">Self-tests</h1>
<p>Framework can perform "self-tests" in order to inform a user 
early on that some fakes (including protocol method fakes) are potentially used inappropriately.</p>
<p>If you use <a href="#context"><code>with-fakes</code></a> macro then self-tests will be run automatically on exiting the block.
Otherwise, when <a href="#context">explicit context</a> is used, you have to invoke self-tests manually.</p>
<p>Currently two types of self-tests are supported to identify:</p>
<ul>
<li>unused fakes </li>
<li>unchecked fakes</li>
</ul>
<h2 id="unused-fakes">Unused Fakes</h2>
<p><code>(fc/self-test-unused-fakes ctx)</code></p>
<p>This function raises an exception when some <a href="#fake">fake</a> was never called after its creation.</p>
<p>For example, this self-test comes in handy when SUT stops using a dependency which 
was faked in several test scenarios. In such case the framework will guide you in cleaning 
 your test suite from the unused stubs.</p>
<h2 id="unchecked-fakes">Unchecked Fakes</h2>
<p><code>(fc/self-test-unchecked-fakes ctx)</code></p>
<p>This self-test raises an exception if some <code>recorded-fake</code> 
was never <a href="#recorded-fake">marked checked</a>, i.e. you forgot assert its calls.</p>
<h1 id="monkey-patching">Monkey Patching</h1>
<p>You can temporarily change a variable value by using <code>patch!</code> macro:</p>
<p><code>(f/patch! var-expr val)</code></p>
<p><code>(fc/patch! ctx var-expr val)</code></p>
<p>After patching original value can still be obtained using a function:</p>
<p><code>(f/original-val a-var)</code></p>
<p><code>(fc/original-val ctx a-var)</code></p>
<p>Also don't forget to unpatch the variable to recover its original value:</p>
<p><code>(f/unpatch! var-expr)</code></p>
<p><code>(fc/unpatch! ctx var-expr)</code></p>
<p>Or unpatch all the variables inside the context at once:</p>
<p><code>(f/unpatch-all!)</code></p>
<p><code>(fc/unpatch-all! ctx)</code></p>
<p>If you use <code>with-fakes</code> then all variables will be unpatched 
automatically on exiting the block, for instance:</p>
<pre><code class="clj">(f/with-fakes
  (f/patch! #'funcs/sum (f/fake [[1 2] &quot;foo&quot;
                                 [3 4] &quot;bar&quot;]))
  (is (= &quot;foo&quot; (funcs/sum 1 2)))
  (is (= &quot;bar&quot; (funcs/sum 3 4))))

; patching is reverted on exiting with-fakes block
(is (= 3 (funcs/sum 1 2)))
</code></pre>

<p>Another example is combining <code>patch</code> and <code>recorded-fake</code> in order
to create a <em>function spy</em> which works exactly the same as the original function
and also records its calls:</p>
<pre><code class="clj">(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))
</code></pre>

<p>Monkey patching is not thread-safe because it changes variable 
in all threads 
(underlying implementation uses <a href="https://clojuredocs.org/clojure.core/alter-var-root"><code>alter-var-root</code></a>/<a href="https://github.com/cljsinfo/cljs-api-docs/blob/catalog/refs/special/setBANG.md"><code>set!</code></a>).</p>
<h1 id="references">References</h1>
<p>The API was mainly inspired by <a href="http://www.jmock.org/">jMock</a> and <a href="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</a> frameworks with
design decisions loosely based on the <a href="http://osherove.com/blog/2013/11/23/fifteen-things-i-look-for-in-an-isolation-framework.html">"Fifteen things I look for in an Isolation framework" by Roy Osherove</a>.</p>
<p>Some alternative frameworks with isolation capabilities:</p>
<ul>
<li><a href="https://github.com/bguthrie/shrubbery">shrubbery</a></li>
<li><a href="https://github.com/EchoTeam/clj-mock">clj-mock</a></li>
<li><a href="https://github.com/marick/Midje">Midje</a></li>
<li><a href="https://github.com/slagyr/speclj">speclj</a></li>
</ul>
<p>Also take at look at the article <a href="http://blog.josephwilk.net/clojure/isolating-external-dependencies-in-clojure.html">"Isolating External Dependencies in Clojure" by Joseph Wilk</a>
which discusses different approaches to mocking in Clojure.</p>
<p>For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:</p>
<ul>
<li>"Test Driven Development: By Example" by Kent Beck</li>
<li>"Growing Object-Oriented Software, Guided by Tests" by Steve Freeman and Nat Pryce [<a href="http://www.growing-object-oriented-software.com/">site</a>]</li>
<li>"xUnit Test Patterns: Refactoring Test Code" by Gerard Meszaros [<a href="http://xunitpatterns.com/">site</a>]</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>