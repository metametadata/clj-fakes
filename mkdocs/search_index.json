{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nclj-fakes is an isolation framework for Clojure/ClojureScript. It makes creating mocks and stubs for unit testing much easier.\n\n\nOne of the unique features of the framework is the ability to find unused fakes in order to help users write more concise test cases.\n\n\nFeatures\n\n\n\n\nAll test doubles are named \"fakes\" to simplify terminology\n\n\nFakes can be created for:\n\n\nprotocol instances\n\n\nfunctions\n\n\n\n\n\n\n\"Nice\" and \"strict\" protocol fakes are supported\n\n\nMonkey patching is supported to fake implicit dependencies\n\n\nSelf-testing: automatically checks for unused fakes\n\n\nTest runner agnostic\n\n\nArrange-Act-Assert style testing\n\n\n\n\nInstallation\n\n\nAdd this to your dependencies in project.clj:\n\n\n[clj-fakes \n0.1.1-SNAPSHOT\n]", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "clj-fakes is an isolation framework for Clojure/ClojureScript. It makes creating mocks and stubs for unit testing much easier.  One of the unique features of the framework is the ability to find unused fakes in order to help users write more concise test cases.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#features", 
            "text": "All test doubles are named \"fakes\" to simplify terminology  Fakes can be created for:  protocol instances  functions    \"Nice\" and \"strict\" protocol fakes are supported  Monkey patching is supported to fake implicit dependencies  Self-testing: automatically checks for unused fakes  Test runner agnostic  Arrange-Act-Assert style testing", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Add this to your dependencies in project.clj:  [clj-fakes  0.1.1-SNAPSHOT ]", 
            "title": "Installation"
        }, 
        {
            "location": "/user-guide/", 
            "text": "Namespaces\n\n\nThe public API is split into two namespaces:\n\n\n\n\nclj-fakes.core\n\n\nclj-fakes.context\n\n\n\n\nThis is how you could require them in Clojure and ClojureScript:\n\n\n; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    [clj-fakes.context :as fc :include-macros true]))\n\n\n\n\nThese namespaces contain almost the same set of members. The difference \nis that \ncore\n uses an implicit context and the \ncontext\n namespace\nfunctions require an explicit context argument.\n\n\nFor your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. \nf/any?\n is the same as \nfc/any?\n).\n\n\nThe private/internal API uses a \n-\n prefix and should not be used (e.g. \n-this-is-some-private-thing\n).\n\n\nContext\n\n\nContext is an object which stores all the information about\ncreated fakes (recorded calls, positions in code, etc.).\nAll fakes have to be created inside some context.\n\n\nTo create a new context use \nclj-fakes.context/context\n:\n\n\n; explicit context\n(let [ctx (fc/context)\n      foo (fc/recorded-fake ctx)]\n  ; ...\n)\n\n\n\n\nAlternatively a new context can be created with \n\nclj-fakes.core/with-fakes\n macro:\n\n\n; implicit context\n(f/with-fakes\n  ; note that now fake is created using a macro from core ns\n  (let [foo (f/recorded-fake)]\n    ; ...\n))\n\n\n\n\nThis approach is preferable since it requires less typing, automatically \nunpatches all patched vars and executes self-tests.\n\n\nInternally \nwith-fakes\n relies on a public dynamic var \n*context*\n which can be \nused in your own helper functions.\n\n\nFunction Fakes\n\n\nFake is a function which returns canned values on matched arguments and can optionally record its calls. It \ncan be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).\n\n\nFake\n\n\nA regular fake function can be created using a macro:\n\n\n(fake [ctx] config)\n\n\nConfig\n is a vector which defines which values to return for different arguments:\n\n\n(let [foo (f/fake [[1 2] \nfoo\n\n                   [3 4 5] \nbar\n])]\n  (foo 1 2) ; =\n \nfoo\n\n  (foo 3 4 5)) ; =\n \nbar\n\n\n\n\n\nIf passed arguments cannot be \nmatched\n using specified config then the exception will be raised:\n\n\n(foo 100 200) ; =\n raises \nUnexpected args are passed into fake: (100 200)\n\n\n\n\n\nA fake is assumed to be called at least once inside the context. Otherwise \nself-test\n exception \nwill be raised. In such case user should either modify a test, an SUT \nor consider using an \noptional fake\n:\n\n\n(f/with-fakes\n  (f/fake [[] nil])) ; =\n raises \nSelf-test: no call detected for: non-optional fake ...\n\n\n\n\n\nIf your test scenario focuses on testing a behavior (e.g. \"assert that foo was called by an SUT\") then do not rely on self-tests, \ninstead use \nrecorded fakes\n with explicit assertions. \nSelf-tests are more about checking usefulness of provided preconditions than \nabout testing expected behavior.\n\n\nOptional Fake\n\n\n(optional-fake [ctx] [config])\n\n\nIt works the same as a regular fake but is not expected to be always called in the context:\n\n\n(f/with-fakes\n  (f/optional-fake [[1 2] 3])) ; =\n ok, self-test will pass\n\n\n\n\nSuch fakes should be used to express the intent of the test writer, \nfor example, when you have to provide a dependency to an SUT,\nbut this dependency is not really related to the test case:\n\n\n(defn process-payments\n  \nProcessor requires a logger.\n\n  [data logger]\n  {:pre [(fn? logger)]}\n  ; ...\n  )\n\n(deftest good-payments-are-processed-without-error\n  (f/with-fakes\n    (let [; ...\n          ; we are not interested in how logger is going to be used, just stub it and forget\n          fake-logger (f/optional-fake)]\n      (is (= :success (process-payments good-payments fake-logger))))))\n\n\n\n\nAs you may have noticed, \nconfig\n argument can be omitted. \nIn such case fake will be created with \n(default-fake-config)\n \nwhich allows any arguments to be passed on invocation.\n\n\nRecorded Fake\n\n\nInvocations of this fake are recorded so that they can later be asserted:\n\n\n(recorded-fake [ctx] [config])\n\n\nUse \ncalls\n function in order to get all recorded invocations for the specified \nrecorded fake. \nIt can also return all the recorded calls in the context if fake is not specified:\n\n\n(let [foo (f/recorded-fake [[integer? integer?] #(+ %1 %2)])\n      bar (f/recorded-fake [[integer? integer?] #(* %1 %2)])]\n  (foo 1 2)\n  (bar 5 6)\n  (foo 7 8)\n\n  (f/calls foo)\n  ; =\n [{:args [1 2] :return-value 3}\n  ;     {:args [7 8] :return-value 15}]\n\n  (f/calls)\n  ; =\n [[foo {:args [1 2] :return-value 3}]\n  ;     [bar {:args [5 6] :return-value 30}]\n  ;     [foo {:args [7 8] :return-value 15}]]\n)\n\n\n\n\nRecorded fake must be checked using one of the \nassertions\n provided by the framework or\nbe marked as checked explicitly using \nmark-checked\n function; otherwise, self-test will raise an exception:\n\n\n(f/with-fakes\n  (f/recorded-fake)) ; =\n raises \nSelf-test: no check performed on: recorded fake ...\n\n\n\n\n\n(f/with-fakes\n  (let [foo (f/recorded-fake)]\n    (f/was-called foo))) ; =\n ok, self-test will pass\n\n\n\n\n(f/with-fakes\n  (f/mark-checked (f/recorded-fake))) ; =\n ok, self-test will pass\n\n\n\n\nFake Configuration\n\n\nFake config should contain pairs of argument matcher and return value:\n\n\n[args-matcher1 fn-or-value1\nargs-matcher2 fn-or-value2 ...]\n\n\n\n\nOn fake invocation argument matchers will be tested from top to bottom and \non the first match the specified value will be returned. If return value is a function than it will be called with passed arguments to generate the return value at runtime:\n\n\n(let [foo (f/fake [[1 2] 100\n                   [3 4] #(+ %1 %2)])]\n  (foo 1 2) ; =\n 100\n  (foo 3 4)) ; =\n 7\n\n\n\n\ndefault-fake-config\n\n\nfc/default-fake-config\n\n\nThis config accepts any arguments and returns a new unique value on each call.\nIt is used by \noptional-fake\n and \nrecorded-fake\n functions when user \ndoesn't specify the config explicitly.\n\n\nArgument Matching\n\n\nProtocol\n\n\nArgument matcher must implement an \nfc/ArgsMatcher\n protocol:\n\n\n(defprotocol ArgsMatcher\n  (args-match? [this args] \nShould return true or false.\n))\n\n\n\n\nIn most cases you won't need to create instances of this protocol manually \nbecause framework provides functional and vector matchers which are useful in most cases.\n\n\nFunctional matcher\n\n\nFunctional matcher is a function which takes a vector of call arguments and returns true/false. \nExample:\n\n\n(let [foo (f/fake [#(odd? (count %)) \nodd number of args\n\n                   #(even? (count %)) \neven number of args\n])]\n  (foo 1 2) ; =\n \neven number of args\n\n  (foo 1 2 3)) ; =\n \nodd number of args\n\n\n\n\n\nIt's actually implemented like this:\n\n\n(extend-type #?(:clj  clojure.lang.Fn\n                :cljs function)\n  ArgsMatcher\n  (args-match? [this args]\n    (this args)))\n\n\n\n\nVector matcher\n\n\nVector matchers were already used all other this guide, they looks like this:\n\n\n[value-or-function1 value-or-function2 ...]\n\n\n\n\nLet's look at the demo:\n\n\n(let [foo (f/fake [[] \nno args\n\n                   [[]] \nempty vector\n\n                   [1 2] \n1 2\n\n                   [integer?] \ninteger\n\n                   [str?] \nstring\n])]\n  (foo) ; =\n \nno args\n\n  (foo []) ; =\n \nempty vector\n\n  (foo 1 2) ; =\n \n1 2\n\n  (foo 1 2 3) ; =\n exception: \nUnexpected args are passed into fake: (1 2 3)\n\n  (foo 123) ; =\n \ninteger\n\n  (foo \nhey\n)) ; =\n \nstring\n\n\n\n\n\nany?\n\n\n(f/any? args)\n\n\n(fc/any? args)\n\n\nThis matcher always returns \ntrue\n for any input arguments:\n\n\n(let [foo (f/fake [[1 2] \n1 2\n\n                   [f/any? f/any? f/any?] \nthree args\n\n                   f/any? \nsomething else\n])]\n  (foo) ; =\n \nsomething else\n\n  (foo 1) ; =\n \nsomething else\n\n  (foo 1 2) ; =\n \n1 2\n\n  (foo 1 2 3) ; =\n \nthree args\n\n  (foo 1 2 3 4)) ; =\n \nsomething else\n\n\n\n\n\nProtocol Fakes\n\n\n\n\n\n\n\n\nFeature\n\n\nreify-fake\n\n\nreify-nice-fake\n\n\n\n\n\n\n\n\n\n\nFake protocol method (explicitly)\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFake protocol method (auto)\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nSupport overloaded protocol methods\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFake Java interface method (explicitly)\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFake Java interface method (auto)\n\n\nNo\n\n\nNo\n\n\n\n\n\n\nFake Object method (explicitly)\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFake Object method (auto)\n\n\nNo\n\n\nNo\n\n\n\n\n\n\nObject can be reified with any new methods\n\n\nNo\n\n\nNo\n\n\n\n\n\n\n\n\nStrict\n\n\n-\n\n\nNice\n\n\n-\n\n\nAssertions\n\n\n-\n\n\nSelf-tests\n\n\n-\n\n\nUnused Fakes\n\n\n-\n\n\nUnchecked Fakes\n\n\n-\n\n\nMonkey Patching\n\n\n-\n\n\nFunction Spy\n\n\nExample:\n\n\n(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))\n\n\n\n\nReferences\n\n\nThe API was mainly inspired by \njMock\n and \nunittest.mock\n frameworks with\ndesign decisions loosely based on the \n\"Fifteen things I look for in an Isolation framework\" by Roy Osherove\n.\n\n\nSome alternative frameworks with isolation capabilities:\n\n\n\n\nclj-mock\n\n\nMidje\n\n\nspeclj\n\n\n\n\nAlso take at look at the article \n\"Isolating External Dependencies in Clojure\" by Joseph Wilk\n\nwhich discusses different approaches to mocking in Clojure.\n\n\nFor more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:\n\n\n\n\n\"Test Driven Development: By Example\" by Kent Beck\n\n\n\"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce [\nsite\n]\n\n\n\"xUnit Test Patterns: Refactoring Test Code\" by Gerard Meszaros [\nsite\n]", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#namespaces", 
            "text": "The public API is split into two namespaces:   clj-fakes.core  clj-fakes.context   This is how you could require them in Clojure and ClojureScript:  ; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    [clj-fakes.context :as fc :include-macros true]))  These namespaces contain almost the same set of members. The difference \nis that  core  uses an implicit context and the  context  namespace\nfunctions require an explicit context argument.  For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g.  f/any?  is the same as  fc/any? ).  The private/internal API uses a  -  prefix and should not be used (e.g.  -this-is-some-private-thing ).", 
            "title": "Namespaces"
        }, 
        {
            "location": "/user-guide/#context", 
            "text": "Context is an object which stores all the information about\ncreated fakes (recorded calls, positions in code, etc.).\nAll fakes have to be created inside some context.  To create a new context use  clj-fakes.context/context :  ; explicit context\n(let [ctx (fc/context)\n      foo (fc/recorded-fake ctx)]\n  ; ...\n)  Alternatively a new context can be created with  clj-fakes.core/with-fakes  macro:  ; implicit context\n(f/with-fakes\n  ; note that now fake is created using a macro from core ns\n  (let [foo (f/recorded-fake)]\n    ; ...\n))  This approach is preferable since it requires less typing, automatically \nunpatches all patched vars and executes self-tests.  Internally  with-fakes  relies on a public dynamic var  *context*  which can be \nused in your own helper functions.", 
            "title": "Context"
        }, 
        {
            "location": "/user-guide/#function-fakes", 
            "text": "Fake is a function which returns canned values on matched arguments and can optionally record its calls. It \ncan be used to define and assert a behavior of an explicit functional dependency of an SUT (system under test).", 
            "title": "Function Fakes"
        }, 
        {
            "location": "/user-guide/#fake", 
            "text": "A regular fake function can be created using a macro:  (fake [ctx] config)  Config  is a vector which defines which values to return for different arguments:  (let [foo (f/fake [[1 2]  foo \n                   [3 4 5]  bar ])]\n  (foo 1 2) ; =   foo \n  (foo 3 4 5)) ; =   bar   If passed arguments cannot be  matched  using specified config then the exception will be raised:  (foo 100 200) ; =  raises  Unexpected args are passed into fake: (100 200)   A fake is assumed to be called at least once inside the context. Otherwise  self-test  exception \nwill be raised. In such case user should either modify a test, an SUT \nor consider using an  optional fake :  (f/with-fakes\n  (f/fake [[] nil])) ; =  raises  Self-test: no call detected for: non-optional fake ...   If your test scenario focuses on testing a behavior (e.g. \"assert that foo was called by an SUT\") then do not rely on self-tests, \ninstead use  recorded fakes  with explicit assertions. \nSelf-tests are more about checking usefulness of provided preconditions than \nabout testing expected behavior.", 
            "title": "Fake"
        }, 
        {
            "location": "/user-guide/#optional-fake", 
            "text": "(optional-fake [ctx] [config])  It works the same as a regular fake but is not expected to be always called in the context:  (f/with-fakes\n  (f/optional-fake [[1 2] 3])) ; =  ok, self-test will pass  Such fakes should be used to express the intent of the test writer, \nfor example, when you have to provide a dependency to an SUT,\nbut this dependency is not really related to the test case:  (defn process-payments\n   Processor requires a logger. \n  [data logger]\n  {:pre [(fn? logger)]}\n  ; ...\n  )\n\n(deftest good-payments-are-processed-without-error\n  (f/with-fakes\n    (let [; ...\n          ; we are not interested in how logger is going to be used, just stub it and forget\n          fake-logger (f/optional-fake)]\n      (is (= :success (process-payments good-payments fake-logger))))))  As you may have noticed,  config  argument can be omitted. \nIn such case fake will be created with  (default-fake-config)  \nwhich allows any arguments to be passed on invocation.", 
            "title": "Optional Fake"
        }, 
        {
            "location": "/user-guide/#recorded-fake", 
            "text": "Invocations of this fake are recorded so that they can later be asserted:  (recorded-fake [ctx] [config])  Use  calls  function in order to get all recorded invocations for the specified \nrecorded fake. \nIt can also return all the recorded calls in the context if fake is not specified:  (let [foo (f/recorded-fake [[integer? integer?] #(+ %1 %2)])\n      bar (f/recorded-fake [[integer? integer?] #(* %1 %2)])]\n  (foo 1 2)\n  (bar 5 6)\n  (foo 7 8)\n\n  (f/calls foo)\n  ; =  [{:args [1 2] :return-value 3}\n  ;     {:args [7 8] :return-value 15}]\n\n  (f/calls)\n  ; =  [[foo {:args [1 2] :return-value 3}]\n  ;     [bar {:args [5 6] :return-value 30}]\n  ;     [foo {:args [7 8] :return-value 15}]]\n)  Recorded fake must be checked using one of the  assertions  provided by the framework or\nbe marked as checked explicitly using  mark-checked  function; otherwise, self-test will raise an exception:  (f/with-fakes\n  (f/recorded-fake)) ; =  raises  Self-test: no check performed on: recorded fake ...   (f/with-fakes\n  (let [foo (f/recorded-fake)]\n    (f/was-called foo))) ; =  ok, self-test will pass  (f/with-fakes\n  (f/mark-checked (f/recorded-fake))) ; =  ok, self-test will pass", 
            "title": "Recorded Fake"
        }, 
        {
            "location": "/user-guide/#fake-configuration", 
            "text": "Fake config should contain pairs of argument matcher and return value:  [args-matcher1 fn-or-value1\nargs-matcher2 fn-or-value2 ...]  On fake invocation argument matchers will be tested from top to bottom and \non the first match the specified value will be returned. If return value is a function than it will be called with passed arguments to generate the return value at runtime:  (let [foo (f/fake [[1 2] 100\n                   [3 4] #(+ %1 %2)])]\n  (foo 1 2) ; =  100\n  (foo 3 4)) ; =  7", 
            "title": "Fake Configuration"
        }, 
        {
            "location": "/user-guide/#default-fake-config", 
            "text": "fc/default-fake-config  This config accepts any arguments and returns a new unique value on each call.\nIt is used by  optional-fake  and  recorded-fake  functions when user \ndoesn't specify the config explicitly.", 
            "title": "default-fake-config"
        }, 
        {
            "location": "/user-guide/#argument-matching", 
            "text": "", 
            "title": "Argument Matching"
        }, 
        {
            "location": "/user-guide/#protocol", 
            "text": "Argument matcher must implement an  fc/ArgsMatcher  protocol:  (defprotocol ArgsMatcher\n  (args-match? [this args]  Should return true or false. ))  In most cases you won't need to create instances of this protocol manually \nbecause framework provides functional and vector matchers which are useful in most cases.", 
            "title": "Protocol"
        }, 
        {
            "location": "/user-guide/#functional-matcher", 
            "text": "Functional matcher is a function which takes a vector of call arguments and returns true/false. \nExample:  (let [foo (f/fake [#(odd? (count %))  odd number of args \n                   #(even? (count %))  even number of args ])]\n  (foo 1 2) ; =   even number of args \n  (foo 1 2 3)) ; =   odd number of args   It's actually implemented like this:  (extend-type #?(:clj  clojure.lang.Fn\n                :cljs function)\n  ArgsMatcher\n  (args-match? [this args]\n    (this args)))", 
            "title": "Functional matcher"
        }, 
        {
            "location": "/user-guide/#vector-matcher", 
            "text": "Vector matchers were already used all other this guide, they looks like this:  [value-or-function1 value-or-function2 ...]  Let's look at the demo:  (let [foo (f/fake [[]  no args \n                   [[]]  empty vector \n                   [1 2]  1 2 \n                   [integer?]  integer \n                   [str?]  string ])]\n  (foo) ; =   no args \n  (foo []) ; =   empty vector \n  (foo 1 2) ; =   1 2 \n  (foo 1 2 3) ; =  exception:  Unexpected args are passed into fake: (1 2 3) \n  (foo 123) ; =   integer \n  (foo  hey )) ; =   string", 
            "title": "Vector matcher"
        }, 
        {
            "location": "/user-guide/#any", 
            "text": "(f/any? args)  (fc/any? args)  This matcher always returns  true  for any input arguments:  (let [foo (f/fake [[1 2]  1 2 \n                   [f/any? f/any? f/any?]  three args \n                   f/any?  something else ])]\n  (foo) ; =   something else \n  (foo 1) ; =   something else \n  (foo 1 2) ; =   1 2 \n  (foo 1 2 3) ; =   three args \n  (foo 1 2 3 4)) ; =   something else", 
            "title": "any?"
        }, 
        {
            "location": "/user-guide/#protocol-fakes", 
            "text": "Feature  reify-fake  reify-nice-fake      Fake protocol method (explicitly)  Yes  Yes    Fake protocol method (auto)  No  Yes    Support overloaded protocol methods  Yes  Yes    Fake Java interface method (explicitly)  Yes  Yes    Fake Java interface method (auto)  No  No    Fake Object method (explicitly)  Yes  Yes    Fake Object method (auto)  No  No    Object can be reified with any new methods  No  No", 
            "title": "Protocol Fakes"
        }, 
        {
            "location": "/user-guide/#strict", 
            "text": "-", 
            "title": "Strict"
        }, 
        {
            "location": "/user-guide/#nice", 
            "text": "-", 
            "title": "Nice"
        }, 
        {
            "location": "/user-guide/#assertions", 
            "text": "-", 
            "title": "Assertions"
        }, 
        {
            "location": "/user-guide/#self-tests", 
            "text": "-", 
            "title": "Self-tests"
        }, 
        {
            "location": "/user-guide/#unused-fakes", 
            "text": "-", 
            "title": "Unused Fakes"
        }, 
        {
            "location": "/user-guide/#unchecked-fakes", 
            "text": "-", 
            "title": "Unchecked Fakes"
        }, 
        {
            "location": "/user-guide/#monkey-patching", 
            "text": "-", 
            "title": "Monkey Patching"
        }, 
        {
            "location": "/user-guide/#function-spy", 
            "text": "Example:  (f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))", 
            "title": "Function Spy"
        }, 
        {
            "location": "/user-guide/#references", 
            "text": "The API was mainly inspired by  jMock  and  unittest.mock  frameworks with\ndesign decisions loosely based on the  \"Fifteen things I look for in an Isolation framework\" by Roy Osherove .  Some alternative frameworks with isolation capabilities:   clj-mock  Midje  speclj   Also take at look at the article  \"Isolating External Dependencies in Clojure\" by Joseph Wilk \nwhich discusses different approaches to mocking in Clojure.  For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:   \"Test Driven Development: By Example\" by Kent Beck  \"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce [ site ]  \"xUnit Test Patterns: Refactoring Test Code\" by Gerard Meszaros [ site ]", 
            "title": "References"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Some notes for framework developers.\n\n\nTests\n\n\nAutorun Clojure tests: \nlein test-refresh\n\n\nRun ClojureScript tests: \nlein clean \n lein doo phantom test once\n\n(clean is needed because there's an issue: ClojureScript plugin does not seem to recompile macros)\n\n\nAutorun ClojureScript tests: \nfswatch -o ./src ./test | xargs -n1 -I{} sh -c 'echo wait.... \n lein clean \n lein doo rhino test once'\n\n\nDocumentation\n\n\nProject uses \nMkDocs\n to generate documentation static site.\n\n\nBuild: \nmkdocs build\n\n\nServe locally with automatic build: \nmkdocs serve\n\n\nDeploy docs to gh-pages branch: \nmkdocs gh-deploy --clean", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#tests", 
            "text": "Autorun Clojure tests:  lein test-refresh  Run ClojureScript tests:  lein clean   lein doo phantom test once \n(clean is needed because there's an issue: ClojureScript plugin does not seem to recompile macros)  Autorun ClojureScript tests:  fswatch -o ./src ./test | xargs -n1 -I{} sh -c 'echo wait....   lein clean   lein doo rhino test once'", 
            "title": "Tests"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  to generate documentation static site.  Build:  mkdocs build  Serve locally with automatic build:  mkdocs serve  Deploy docs to gh-pages branch:  mkdocs gh-deploy --clean", 
            "title": "Documentation"
        }
    ]
}