{
    "docs": [
        {
            "location": "/", 
            "text": "clj-fakes\n is an isolation framework for Clojure/ClojureScript that makes creating \ntest doubles\n much easier.\n\n\n\n\n\n\nFeatures\n\n\n\n\nAll test doubles are named \"fakes\" to simplify the terminology.\n\n\nFakes can be created for:\n\n\nfunctions\n\n\ninstances of protocols and Java interfaces\n\n\n\n\n\n\n\"Nice\" and \"strict\" protocol fakes are supported.\n\n\nMonkey patching is supported to fake implicit dependencies.\n\n\nSeveral functions are provided for asserting recorded calls.\n\n\nSelf-testing: automatically checks for unused fakes.\n\n\nInformative error messages.\n\n\nTest runner agnostic.\n\n\nArrange-Act-Assert style testing.\n\n\n\n\nInstallation\n\n\nRequirements: Clojure 1.7.0 and/or ClojureScript 1.7.28 or higher.\n\n\nAdd this to your dependencies:\n\n\n[clj-fakes \n0.6.0\n]\n\n\n\n\nRequire framework namespace in your unit test source file:\n\n\n; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    ; and/or:\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    ; and/or:\n    [clj-fakes.context :as fc :include-macros true]))\n\n\n\n\nExamples\n\n\nCreating Faking Context\n\n\nExplicit context:\n\n\n(let [ctx (fc/context)]\n  ; use clj-fakes.context API here\n)\n\n\n\n\nImplicit context:\n\n\n(f/with-fakes\n  ; use clj-fakes.core API here \n)\n; on exit block will automatically unpatch all patched vars and execute self-tests\n\n\n\n\nAll the following examples are assumed to be used inside an implicit context.\n\n\nStubbing\n\n\nFunction Stub\n\n\n(let [foo (f/fake [[1 2] \nfoo\n\n                   [3 4 5] \nbar\n])]\n  (foo 1 2) ; =\n \nfoo\n\n  (foo 3 4 5) ; =\n \nbar\n\n  (foo 100 200)) ; =\n raises \nUnexpected args are passed into fake: (100 200) ...\n\n\n\n\n\nMethod Stub\n\n\n(let [cow (f/reify-fake AnimalProtocol\n                        (sleep :fake [[] \nzzz\n]))]\n  (p/sleep cow) ; =\n \nzzz\n\n  (p/speak cow)) ; =\n undefined method exception\n\n\n\n\nNice Method Stub\n\n\n(let [cow (f/reify-nice-fake p/AnimalProtocol)]\n  (p/sleep cow) ; =\n FakeReturnValue\n  (p/speak cow)) ; =\n FakeReturnValue \n\n\n\n\nMocking\n\n\nFunction Mock\n\n\n(let [foo (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(+ %1 %2)])\n      bar (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(* %1 %2)])]\n  (foo 1 2)\n  (bar 5 6)\n  (foo 7 8)\n\n  (f/calls foo)\n  ; =\n [{:args [1 2] :return-value 3}\n  ;     {:args [7 8] :return-value 15}]\n\n  (f/calls)\n  ; =\n [[foo {:args [1 2] :return-value 3}]\n  ;     [bar {:args [5 6] :return-value 30}]\n  ;     [foo {:args [7 8] :return-value 15}]]\n)\n\n\n\n\nMethod Mock\n\n\n(let [cow (f/reify-fake p/AnimalProtocol\n                        (speak :recorded-fake [f/any? \nmoo\n]))]\n  (p/speak cow)\n\n  (f/calls (f/method cow p/speak))) ; =\n [{:args ..., :return-value moo}]\n\n\n\n\nAssertions\n\n\nStrictly One Call\n\n\n(f/was-called-once foo [1 2])\n\n\n\n\n(f/method-was-called-once p/speak cow [\nBob\n])\n\n\n\n\nAt Least One Call\n\n\n(f/was-called foo [1 2])\n\n\n\n\n(f/method-was-called p/speak cow [\nBob\n])\n\n\n\n\nNo Calls\n\n\n(f/was-not-called foo)\n\n\n\n\n(f/method-was-not-called p/speak cow)\n\n\n\n\nCalls In Specified Order\n\n\n(f/were-called-in-order\n  foo [1 2 3]\n  foo [(f/arg integer?)]\n  bar [100 200]\n  baz [300])\n\n\n\n\n(f/methods-were-called-in-order\n  p/speak cow []\n  p/sleep cow []\n  p/eat dog [\ndog food\n \nwater\n]\n  p/speak cow [\nBob\n])\n\n\n\n\nMonkey Patching\n\n\nPatch Function With Stub\n\n\n(f/with-fakes\n  (f/patch! #'funcs/sum (f/fake [[1 2] \nfoo\n\n                                 [3 4] \nbar\n]))\n  (funcs/sum 1 2) ; =\n \nfoo\n\n  (funcs/sum 3 4)) ; =\n \nbar\n\n\n; patching is reverted on exiting with-fakes block\n(funcs/sum 1 2) ; =\n 3\n\n\n\n\nPatch and Spy\n\n\n(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))\n(funcs/sum 1 2) ; =\n 3\n(f/was-called funcs/sum [1 2]) ; =\n true\n\n\n\n\nSelf-tests\n\n\n(f/with-fakes\n  (f/fake [f/any? nil]))\n; =\n raises \nSelf-test: no call detected for: non-optional fake ...\n\n\n\n\n\n(f/with-fakes\n  (f/recorded-fake))\n; =\n raises \nSelf-test: no check performed on: recorded fake ...\n\n\n\n\n\nDocumentation\n\n\nMore documentation can be found at \nthe project site\n:\n\n\n\n\nQuickstart\n\n\nUser Guide\n\n\nAPI Reference\n\n\nDeveloper Guide\n\n\n\n\nLicense\n\n\nCopyright \u00a9 2015 Yuri Govorushchenko.\n\n\nReleased under an MIT license.", 
            "title": "Readme"
        }, 
        {
            "location": "/#features", 
            "text": "All test doubles are named \"fakes\" to simplify the terminology.  Fakes can be created for:  functions  instances of protocols and Java interfaces    \"Nice\" and \"strict\" protocol fakes are supported.  Monkey patching is supported to fake implicit dependencies.  Several functions are provided for asserting recorded calls.  Self-testing: automatically checks for unused fakes.  Informative error messages.  Test runner agnostic.  Arrange-Act-Assert style testing.", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Requirements: Clojure 1.7.0 and/or ClojureScript 1.7.28 or higher.  Add this to your dependencies:  [clj-fakes  0.6.0 ]  Require framework namespace in your unit test source file:  ; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    ; and/or:\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    ; and/or:\n    [clj-fakes.context :as fc :include-macros true]))", 
            "title": "Installation"
        }, 
        {
            "location": "/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/#creating-faking-context", 
            "text": "Explicit context:  (let [ctx (fc/context)]\n  ; use clj-fakes.context API here\n)  Implicit context:  (f/with-fakes\n  ; use clj-fakes.core API here \n)\n; on exit block will automatically unpatch all patched vars and execute self-tests  All the following examples are assumed to be used inside an implicit context.", 
            "title": "Creating Faking Context"
        }, 
        {
            "location": "/#stubbing", 
            "text": "", 
            "title": "Stubbing"
        }, 
        {
            "location": "/#function-stub", 
            "text": "(let [foo (f/fake [[1 2]  foo \n                   [3 4 5]  bar ])]\n  (foo 1 2) ; =   foo \n  (foo 3 4 5) ; =   bar \n  (foo 100 200)) ; =  raises  Unexpected args are passed into fake: (100 200) ...", 
            "title": "Function Stub"
        }, 
        {
            "location": "/#method-stub", 
            "text": "(let [cow (f/reify-fake AnimalProtocol\n                        (sleep :fake [[]  zzz ]))]\n  (p/sleep cow) ; =   zzz \n  (p/speak cow)) ; =  undefined method exception", 
            "title": "Method Stub"
        }, 
        {
            "location": "/#nice-method-stub", 
            "text": "(let [cow (f/reify-nice-fake p/AnimalProtocol)]\n  (p/sleep cow) ; =  FakeReturnValue\n  (p/speak cow)) ; =  FakeReturnValue", 
            "title": "Nice Method Stub"
        }, 
        {
            "location": "/#mocking", 
            "text": "", 
            "title": "Mocking"
        }, 
        {
            "location": "/#function-mock", 
            "text": "(let [foo (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(+ %1 %2)])\n      bar (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(* %1 %2)])]\n  (foo 1 2)\n  (bar 5 6)\n  (foo 7 8)\n\n  (f/calls foo)\n  ; =  [{:args [1 2] :return-value 3}\n  ;     {:args [7 8] :return-value 15}]\n\n  (f/calls)\n  ; =  [[foo {:args [1 2] :return-value 3}]\n  ;     [bar {:args [5 6] :return-value 30}]\n  ;     [foo {:args [7 8] :return-value 15}]]\n)", 
            "title": "Function Mock"
        }, 
        {
            "location": "/#method-mock", 
            "text": "(let [cow (f/reify-fake p/AnimalProtocol\n                        (speak :recorded-fake [f/any?  moo ]))]\n  (p/speak cow)\n\n  (f/calls (f/method cow p/speak))) ; =  [{:args ..., :return-value moo}]", 
            "title": "Method Mock"
        }, 
        {
            "location": "/#assertions", 
            "text": "", 
            "title": "Assertions"
        }, 
        {
            "location": "/#strictly-one-call", 
            "text": "(f/was-called-once foo [1 2])  (f/method-was-called-once p/speak cow [ Bob ])", 
            "title": "Strictly One Call"
        }, 
        {
            "location": "/#at-least-one-call", 
            "text": "(f/was-called foo [1 2])  (f/method-was-called p/speak cow [ Bob ])", 
            "title": "At Least One Call"
        }, 
        {
            "location": "/#no-calls", 
            "text": "(f/was-not-called foo)  (f/method-was-not-called p/speak cow)", 
            "title": "No Calls"
        }, 
        {
            "location": "/#calls-in-specified-order", 
            "text": "(f/were-called-in-order\n  foo [1 2 3]\n  foo [(f/arg integer?)]\n  bar [100 200]\n  baz [300])  (f/methods-were-called-in-order\n  p/speak cow []\n  p/sleep cow []\n  p/eat dog [ dog food   water ]\n  p/speak cow [ Bob ])", 
            "title": "Calls In Specified Order"
        }, 
        {
            "location": "/#monkey-patching", 
            "text": "", 
            "title": "Monkey Patching"
        }, 
        {
            "location": "/#patch-function-with-stub", 
            "text": "(f/with-fakes\n  (f/patch! #'funcs/sum (f/fake [[1 2]  foo \n                                 [3 4]  bar ]))\n  (funcs/sum 1 2) ; =   foo \n  (funcs/sum 3 4)) ; =   bar \n\n; patching is reverted on exiting with-fakes block\n(funcs/sum 1 2) ; =  3", 
            "title": "Patch Function With Stub"
        }, 
        {
            "location": "/#patch-and-spy", 
            "text": "(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))\n(funcs/sum 1 2) ; =  3\n(f/was-called funcs/sum [1 2]) ; =  true", 
            "title": "Patch and Spy"
        }, 
        {
            "location": "/#self-tests", 
            "text": "(f/with-fakes\n  (f/fake [f/any? nil]))\n; =  raises  Self-test: no call detected for: non-optional fake ...   (f/with-fakes\n  (f/recorded-fake))\n; =  raises  Self-test: no check performed on: recorded fake ...", 
            "title": "Self-tests"
        }, 
        {
            "location": "/#documentation", 
            "text": "More documentation can be found at  the project site :   Quickstart  User Guide  API Reference  Developer Guide", 
            "title": "Documentation"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright \u00a9 2015 Yuri Govorushchenko.  Released under an MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quickstart\n\n\n1) I assume your Clojure/ClojureScript project is automated using \nLeiningen\n and \nalready has unit tests implemented with some unit testing framework. \n\n\nI will use a built-in\n\nclojure.test/cljs.test\n \nframework in this documentation. To learn how to use it:\n\n\n\n\nin Clojure: see \nLeiningen tutorial\n and\n \nlein-test-refresh\n plugin;\n\n\nin ClojureScript: see \nwiki\n and \n\ndoo\n plugin for running unit tests.\n\n\n\n\n2) Add framework dependency into \nproject.clj\n (the framework is hosted on \nClojars\n):\n\n\n:dependencies [...\n               [clj-fakes \ninsert here the latest version from Clojars\n]]\n\n\n\n\n3) Require framework namespace in your unit test source file:\n\n\n; Clojure\n(ns unit.example\n  (:require\n    ; ...\n    [clojure.test :refer :all]\n    [clj-fakes.core :as f]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    ; ...\n    [cljs.test :refer-macros [is deftest]]\n    [clj-fakes.core :as f :include-macros true]))\n\n\n\n\n4) Now you can write a simple unit test which creates and calls a fake function:\n\n\n(deftest fakes-work\n  (f/with-fakes\n    (let [hello (f/fake [[] \nhello, world\n])]\n      (is (= \nhello, world\n (hello))))))", 
            "title": "Quickstart"
        }, 
        {
            "location": "/quickstart/#quickstart", 
            "text": "1) I assume your Clojure/ClojureScript project is automated using  Leiningen  and \nalready has unit tests implemented with some unit testing framework.   I will use a built-in clojure.test/cljs.test  \nframework in this documentation. To learn how to use it:   in Clojure: see  Leiningen tutorial  and\n  lein-test-refresh  plugin;  in ClojureScript: see  wiki  and  doo  plugin for running unit tests.   2) Add framework dependency into  project.clj  (the framework is hosted on  Clojars ):  :dependencies [...\n               [clj-fakes  insert here the latest version from Clojars ]]  3) Require framework namespace in your unit test source file:  ; Clojure\n(ns unit.example\n  (:require\n    ; ...\n    [clojure.test :refer :all]\n    [clj-fakes.core :as f]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    ; ...\n    [cljs.test :refer-macros [is deftest]]\n    [clj-fakes.core :as f :include-macros true]))  4) Now you can write a simple unit test which creates and calls a fake function:  (deftest fakes-work\n  (f/with-fakes\n    (let [hello (f/fake [[]  hello, world ])]\n      (is (=  hello, world  (hello))))))", 
            "title": "Quickstart"
        }, 
        {
            "location": "/user-guide/", 
            "text": "Namespaces\n\n\nThe public API is split into two namespaces:\n\n\n\n\nclj-fakes.core\n\n\nclj-fakes.context\n\n\n\n\nThis is how you could require them in Clojure and ClojureScript:\n\n\n; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    [clj-fakes.context :as fc :include-macros true]))\n\n\n\n\nThese namespaces contain almost the same set of members. The difference \nis that \ncore\n uses an implicit context and the \ncontext\n namespace\nfunctions require an explicit context argument.\n\n\nFor your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g. \nf/any?\n is the same as \nfc/any?\n).\n\n\nThe private/internal API uses a \n-\n prefix and should not be used (e.g. \n-this-is-some-private-thing\n).\n\n\nContext\n\n\nContext is an object which stores all the information about\ncreated fakes (recorded calls, positions in code, etc.).\nAll fakes have to be created inside some context.\n\n\nTo create a new context use \nclj-fakes.context/context\n:\n\n\n; explicit context\n(let [ctx (fc/context)\n      foo (fc/recorded-fake ctx)]\n  ; ...\n)\n\n\n\n\nAlternatively a new context can be created with \n\nclj-fakes.core/with-fakes\n macro:\n\n\n; implicit context\n(f/with-fakes\n  ; note that now fake is created using a macro from core ns\n  (let [foo (f/recorded-fake)]\n    ; ...\n))\n\n\n\n\nThis approach is preferable since it requires less typing, automatically \nunpatches all \npatched vars\n and executes \nself-tests\n.\n\n\nInternally \nwith-fakes\n relies on a public dynamic variable \n*context*\n which can be \nused in your own helper functions.\n\n\nFunction Fakes\n\n\nFake is a function which returns canned values on matched arguments and can optionally record its calls. It \ncan be used to define and assert a behavior of a functional dependency of an SUT (system under test).\n\n\nFake\n\n\nA regular fake function can be created using a macro:\n\n\n(f/fake config)\n\n\n(fc/fake ctx config)\n\n\nConfig\n is a vector which defines which values to return for different arguments:\n\n\n(let [foo (f/fake [[1 2] \nfoo\n\n                   [3 4 5] \nbar\n])]\n  (foo 1 2) ; =\n \nfoo\n\n  (foo 3 4 5)) ; =\n \nbar\n\n\n\n\n\nIf passed arguments cannot be \nmatched\n using specified \nconfig then the exception will be raised:\n\n\n(foo 100 200) ; =\n raises \nUnexpected args are passed into fake: (100 200) ...\n\n\n\n\n\nA fake is assumed to be called at least once inside the context; otherwise, \nself-test\n exception \nwill be raised. In such case user should either modify a test, an SUT \nor consider using an \noptional fake\n:\n\n\n(f/with-fakes\n  (f/fake [[] nil])) ; =\n raises \nSelf-test: no call detected for: non-optional fake ...\n\n\n\n\n\nIf your test scenario focuses on testing a behavior (e.g. \"assert that foo was called by an SUT\") then do not rely on self-tests, \ninstead use \nrecorded fakes\n with explicit \nassertions\n. \nSelf-tests are more about checking usefulness of provided preconditions than \nabout testing expected behavior.\n\n\nOptional Fake\n\n\n(f/optional-fake [config])\n\n\n(fc/optional-fake ctx [config])\n\n\nIt works the same as a regular fake but is not expected to be always called in the context:\n\n\n(f/with-fakes\n  (f/optional-fake [[1 2] 3])) ; =\n ok, self-test will pass\n\n\n\n\nSuch fakes should be used to express the intent of the test writer, \nfor example, when you have to provide a dependency to an SUT,\nbut this dependency is not really related to the test case:\n\n\n(defn process-payments\n  \nProcessor requires a logger.\n\n  [data logger]\n  {:pre [(fn? logger)]}\n  ; ...\n  )\n\n(deftest good-payments-are-processed-without-error\n  (f/with-fakes\n    (let [; ...\n          ; we are not interested in how logger is going to be used, just stub it and forget\n          fake-logger (f/optional-fake)]\n      (is (= :success (process-payments good-payments fake-logger))))))\n\n\n\n\nAs you may have noticed, \nconfig\n argument can be omitted. \nIn such case fake will be created with \ndefault-fake-config\n \nwhich allows any arguments to be passed on invocation.\n\n\nRecorded Fake\n\n\nInvocations of this fake are recorded so that they can later be asserted:\n\n\n(f/recorded-fake [config])\n\n\n(fc/recorded-fake ctx [config])\n\n\nUse \ncalls\n function in order to get all recorded invocations for the specified \nrecorded fake. \nIt can also return all the recorded calls in the context if fake is not specified:\n\n\n(let [foo (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(+ %1 %2)])\n      bar (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(* %1 %2)])]\n  (foo 1 2)\n  (bar 5 6)\n  (foo 7 8)\n\n  (f/calls foo)\n  ; =\n [{:args [1 2] :return-value 3}\n  ;     {:args [7 8] :return-value 15}]\n\n  (f/calls)\n  ; =\n [[foo {:args [1 2] :return-value 3}]\n  ;     [bar {:args [5 6] :return-value 30}]\n  ;     [foo {:args [7 8] :return-value 15}]]\n)\n\n\n\n\nRecorded fake must be checked using one of the \nassertions\n provided by the framework or\nbe marked as checked explicitly using \nmark-checked\n function; \notherwise, \nself-test\n will raise an exception:\n\n\n(f/with-fakes\n  (f/recorded-fake)) ; =\n raises \nSelf-test: no check performed on: recorded fake ...\n\n\n\n\n\n(f/with-fakes\n  (let [foo (f/recorded-fake)]\n    (foo)\n    (is (f/was-called foo [])))) ; =\n ok, self-test will pass\n\n\n\n\n(f/with-fakes\n  (f/mark-checked (f/recorded-fake))) ; =\n ok, self-test will pass\n\n\n\n\nCustom Macros\n\n\nIn your own reusable macros you should use \nfake*/recorded-fake*\n \ninstead of \nfake/recorded-fake\n:\n\n\n(f/fake* form config)\n\n\n(fc/fake* ctx form config)\n\n\n(f/recorded-fake* form [config])\n\n\n(fc/recorded-fake* ctx form [config])\n\n\nIn other words, your macro must explicitly provide \nform\n to framework macros; \notherwise, due to implementation details, framework will not be \nable to correctly determine fake function line numbers which is crucial for debugging. \n\n\nThe framework will warn you if you accidentally use the version without asterisk \nin your macro.\n\n\nFake Configuration\n\n\nFake config should contain pairs of \nargs matcher\n and return value:\n\n\n[args-matcher1 fn-or-value1\nargs-matcher2 fn-or-value2 ...]\n\n\n\n\nOn fake invocation matchers will be tested from top to bottom and \non the first match the specified value will be returned. \nIf return value is a function than it will be called with passed arguments to generate the return value at runtime:\n\n\n(let [foo (f/fake [[1 2] 100\n                   [3 4] #(+ %1 %2)\n                   [5 6] (fn [_ _] (throw (ex-info \nwow\n {})))])]\n  (foo 1 2) ; =\n 100\n  (foo 3 4) ; =\n 7\n  (foo 5 6)) ; =\n raises \nwow\n exception\n\n\n\n\nThere's one built-in config in the framework:\n\n\nfc/default-fake-config\n\n\nIt accepts any number of arguments and returns a new unique \ninstance of type \nFakeReturnValue\n on each call.\nIt is used by \noptional-fake\n and \nrecorded-fake\n functions by default (i.e. when user \ndoesn't specify the config explicitly).\n\n\nHelpers\n\n\n(f/cyclically coll)\n\n\n(fc/cyclically coll)\n\n\nThis function can be used to implement iterator-style stubbing \nwhen a fake returns a different value on each call:\n\n\n(let [get-weekday (f/fake [[\nMy event\n] (f/cyclically [:monday :tuesday :wednesday])])]\n  (is (= :monday (get-weekday \nMy event\n)))\n  (is (= :tuesday (get-weekday \nMy event\n)))\n  (is (= :wednesday (get-weekday \nMy event\n)))\n  (is (= :monday (get-weekday \nMy event\n))))\n\n\n\n\nArgument Matching\n\n\nEvery arguments matcher must implement an \nfc/ArgsMatcher\n protocol:\n\n\n(defprotocol ArgsMatcher\n  (args-match? [this args] \nShould return true or false.\n)\n  (args-matcher-\nstr [this] \nShould return a string for debug messages.\n))\n\n\n\n\nIn most cases you won't need to create instances of this protocol manually \nbecause framework provides vector matchers which are useful in most cases.\n\n\nVector Matcher\n\n\nVector matchers were already used all other this guide. \nEach vector element can be an expected value or an \nfc/ImplicitArgMatcher\n instance:\n\n\n[implicit-arg-matcher-or-exact-value1 implicit-arg-matcher-or-exact-value2 ...]\n\n\n\n\n(defprotocol ImplicitArgMatcher\n  (arg-matches-implicitly? [this arg] \nShould return true or false.\n)\n  (arg-matcher-\nstr [this] \nShould return a string for debug messages.\n))\n\n\n\n\nIt is not recommended to extend existing types with \nImplicitArgMatcher\n protocol; \ninstead, to make code more explicit and future-proof, \nyou should use an \narg\n \"adapter\" macro and pass it \nArgMatcher\n instances:\n\n\n(let [foo (f/fake [[] \nno args\n\n                   [[]] \nempty vector\n\n                   [1 2] \n1 2\n\n                   [(f/arg integer?) (f/arg integer?)] \ntwo integers\n\n                   [(f/arg string?)] \nstring\n])]\n  (foo) ; =\n \nno args\n\n  (foo []) ; =\n \nempty vector\n\n  (foo 1 2) ; =\n \n1 2\n\n  (foo 1 2 3) ; =\n exception: \nUnexpected args are passed into fake: (1 2 3) ...\n\n  (foo 100 200) ; =\n \ntwo integers\n\n  (foo \nhey\n)) ; =\n \nstring\n\n\n\n\n\nAs you can see, the framework already supports \nfunctional argument matchers\n \nwhich are implemented by extending function type like this:\n\n\n(extend-type #?(:clj  clojure.lang.Fn\n                :cljs function)\n  ArgMatcher\n  (arg-matches? [this arg]\n    (this arg)))\n\n\n\n\nYou are encouraged to define your own argument matchers in a similar way.\n\n\nThe framework also supports \nregex matchers\n (using \n\nre-find\n under the hood), for example: \n(f/arg #\"abc.*\")\n.\n\n\nany?\n\n\n(f/any? _)\n\n\n(fc/any? _)\n\n\nThis special matcher always returns \ntrue\n for any input arguments. \nIt can be used to match single and multiple arguments:\n\n\n(let [foo (f/fake [[1 2] \n1 2\n\n                   [f/any? f/any? f/any?] \nthree args\n\n                   f/any? \nsomething else\n])]\n  (foo) ; =\n \nsomething else\n\n  (foo 1) ; =\n \nsomething else\n\n  (foo 1 2) ; =\n \n1 2\n\n  (foo 1 2 3) ; =\n \nthree args\n\n  (foo 1 2 3 4)) ; =\n \nsomething else\n\n\n\n\n\nProtocol Fakes\n\n\nFramework defines two new macros for reifying protocols \nusing function fakes described earlier. So, for example, \nyou can record and assert method calls on reified instances.\n\n\nThe \"strict\" \nreify-fake\n macro is very similar to \nreify\n; in particular, \ncreated instance will raise an exception \non calling protocol method which is not defined. \n\n\nOn the other hand, \nreify-nice-fake\n is able to automatically \ngenerate \noptional-fake\n implementations for methods which are \nnot explicitly defined by user. \n\n\nWhich macro to use solely depends on your testing style. I'd \nrecommend to use nice fakes whenever possible in order to make \ntests more compact and break less often on code changes.\n\n\nThere are some subtleties, so here's a table to give you an overview of \nwhich features are currently supported:\n\n\n\n\n\n\n\n\nFeature\n\n\nreify-fake\n\n\nreify-nice-fake\n\n\n\n\n\n\n\n\n\n\nFake protocol method (explicitly)\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFake protocol method (auto)\n\n\n-\n\n\nYes\n\n\n\n\n\n\nFake Java interface method (explicitly)\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFake Java interface method (auto)\n\n\n-\n\n\nNo\n\n\n\n\n\n\nFake Object method (explicitly)\n\n\nYes\n\n\nOnly in Clojure\n\n\n\n\n\n\nFake Object method (auto)\n\n\n-\n\n\nNo\n\n\n\n\n\n\nObject can be reified with any new methods\n\n\nOnly in ClojureScript\n\n\nOnly in ClojureScript\n\n\n\n\n\n\nSupport overloaded methods\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nSyntax\n\n\nThe syntax is very similar to the built-in \nreify\n macro:\n\n\n(f/reify-fake specs*)\n\n\n(fc/reify-fake ctx specs*)\n\n\n(f/reify-nice-fake specs*)\n\n\n(fc/reify-nice-fake ctx specs*)\n\n\nEach spec consists of the protocol or interface name followed by zero\nor more method fakes:\n\n\nprotocol-or-interface-or-Object\n(method-name [arglist] fake-type [config])*\n\n\n\n\nAvailable fake types:\n\n\n\n\n:fake\n (see \nFake\n)\n\n\n:optional-fake\n (see \nOptional Fake\n)\n\n\n:recorded-fake\n (see \nRecorded Fake\n)\n\n\n\n\nAs with function fakes, config can be omitted for \n:optional-fake\n and \n:recorded-fake\n:\n\n\n(defprotocol AnimalProtocol\n  (speak [this] [this name] [this name1 name2])\n  (eat [this food drink])\n  (sleep [this]))\n\n(defprotocol FileProtocol\n  (save [this])\n  (scan [this]))\n\n; ...\n\n(f/reify-fake\n  p/AnimalProtocol\n  (sleep :fake [f/any? \nzzz\n])\n  (speak :recorded-fake)\n\n  p/FileProtocol\n  (save :optional-fake)\n\n  java.lang.CharSequence\n  (charAt :recorded-fake [f/any? \\a]))\n\n\n\n\nAlthough protocol methods always have a first \nthis\n argument, \nmethod configs must not try to match this argument. \nHowever, the return value function will receive all the arguments on invocation, \nincluding \nthis\n:\n\n\n(let [monkey (f/reify-fake p/AnimalProtocol\n                           ; config only matches |food| and |drink| arguments\n                           ; but return value function will get all 3 arguments on call\n                           (eat :fake [[f/any? f/any?] #(str \nate \n %2 \n and drank \n %3)]))]\n      (println (p/eat monkey \nbanana\n \nwater\n))) ; =\n ate banana and drank water\n\n\n\n\nIn ClojureScript it's possible to implement any methods under \nObject\n protocol.\nThe framework supports this scenario but requires an arglist explicitly specified after the method name\n(\nthis\n arg should be omitted):\n\n\n(let [calculator (f/reify-fake Object\n                               (sum [x y] :fake [[f/any? f/any?] #(+ %2 %3)]))]\n  (is (= 5 (.sum calculator 2 3))))\n\n\n\n\nCalls \n Assertions\n\n\nIn order to get and assert recorded method calls there's a \nhelper function:\n\n\n(f/method obj f)\n\n\n(fc/method ctx obj f)\n\n\nIt can be used in combination with existing \ncalls\n and \nwas-called-*\n functions like this:\n\n\n(f/with-fakes\n  (let [cow (f/reify-fake p/AnimalProtocol\n                          (speak :recorded-fake [f/any? \nmoo\n]))]\n    (p/speak cow)\n    (println (f/calls (f/method cow p/speak))) ; =\n [{:args ..., :return-value moo}]\n    (is (f/was-called-once (f/method cow p/speak) [cow]))))\n\n\n\n\nNotice how object name \ncow\n is duplicated at the last line. In order to get \nrid of such duplications there are additional \nmethod-*\n assertions defined. \nSo the last expression can be rewritten like this:\n\n\n(is (f/method-was-called-once p/speak cow []))\n\n\n\n\nFor the list of all available assertion functions see \nAssertions\n.\n\n\nThere's a quirk when Java interface or ClojureScript \nObject\n method is faked: you will need to use its\nstring representation in \nmethod\n/\nmethod-*\n:\n\n\n(let [foo (f/reify-fake clojure.lang.IFn\n                        (invoke :recorded-fake))]\n  (foo 1 2 3)\n  (is (f/method-was-called \ninvoke\n foo [1 2 3])))\n\n\n\n\nCustom Macros\n\n\nIn your own reusable macros you should use \nreify-fake*/reify-nice-fake*\n \ninstead of \nreify-fake/reify-nice-fake\n:\n\n\n(f/reify-fake* form env specs*)\n\n\n(fc/reify-fake* ctx form env specs*)\n\n\n(f/reify-nice-fake* form env specs*)\n\n\n(fc/reify-nice-fake* ctx form env specs*)\n\n\nIn other words, your macro must explicitly provide \nform\n and \nenv\n to framework macros; \notherwise, due to implementation details, framework will not be \nable to correctly determine fake method line numbers which is crucial for debugging. \n\n\nFor instance:\n\n\n(defmacro my-reify-fake\n  [\n specs]\n  `(f/reify-fake* ~\nform ~\nenv ~@specs))\n\n\n\n\nThe framework will warn you if you accidentally use the version without asterisk \nin your macro.\n\n\nAssertions\n\n\nFramework provides several assertion functions for \nrecorded fakes\n. \nEach function either returns \ntrue\n or raises an exception with additional details:\n\n\n(f/was-called-once f args-matcher)\n\n- checks that function was called strictly once and that the call was with the specified args.\n\n\n(f/was-called f args-matcher)\n\n- checks that function was called at least once with the specified args.\n\n\n(f/was-not-called f)\n\n- checks that function was never called.\n\n\n(f/were-called-in-order f1 args-matcher1 f2 args-matcher2 ...)\n\n- checks that functions were called in specified order (but it doesn't guarantee there were no other calls).\n\n\nThe set of similar functions is defined for \nprotocol methods\n:\n\n\n(f/method-was-called-once f obj args-matcher)\n\n\n(f/method-was-called f obj args-matcher)\n\n\n(f/method-was-not-called f obj)\n\n\n(f/methods-were-called-in-order f1 obj1 args-matcher1 f2 obj2 args-matcher2 ...)\n\n\nOf course, all these functions can be called with an explicit context:\n\n\n(fc/was-called-once ctx f args-matcher)\n\n\n(fc/was-called ctx f args-matcher)\n\n\n(fc/was-not-called ctx f)\n\n\n(fc/were-called-in-order ctx f1 args-matcher1 f2 args-matcher2 ...)\n\n\n(fc/method-was-called-once ctx f obj args-matcher)\n\n\n(fc/method-was-called ctx f obj args-matcher)\n\n\n(fc/method-was-not-called ctx f obj)\n\n\n(fc/methods-were-called-in-order ctx f1 obj1 args-matcher1 f2 obj2 args-matcher2 ...)\n\n\nSelf-tests\n\n\nFramework can perform \"self-tests\" in order to inform a user \nearly on that some fakes (including protocol method fakes) are potentially used inappropriately.\n\n\nIf you use \nwith-fakes\n macro then self-tests will be run automatically on exiting the block.\nOtherwise, when \nexplicit context\n is used, you have to invoke self-tests manually\nusing next function:\n\n\n(fc/self-test ctx)\n\n\nEach test can also be run manually using dedicated functions.\nCurrently two types of self-tests are supported to identify:\n\n\n\n\nunused fakes \n\n\nunchecked fakes\n\n\n\n\nUnused Fakes\n\n\n(fc/self-test-unused-fakes ctx)\n\n\nThis function raises an exception when some \nfake\n was never called after its creation.\n\n\nFor example, this self-test comes in handy when SUT stops using a dependency which \nwas faked in several test scenarios. In such case the framework will guide you in cleaning \n your test suite from the unused stubs.\n\n\nUnchecked Fakes\n\n\n(fc/self-test-unchecked-fakes ctx)\n\n\nThis self-test raises an exception if some \nrecorded-fake\n \nwas never \nmarked checked\n, i.e. you forgot to assert its calls.\n\n\nMonkey Patching\n\n\nYou can temporarily change a variable value by using \npatch!\n macro:\n\n\n(f/patch! var-expr val)\n\n\n(fc/patch! ctx var-expr val)\n\n\nAfter patching original value can still be obtained using a function:\n\n\n(f/original-val a-var)\n\n\n(fc/original-val ctx a-var)\n\n\nAlso don't forget to unpatch the variable to recover its original value:\n\n\n(f/unpatch! var-expr)\n\n\n(fc/unpatch! ctx var-expr)\n\n\nOr unpatch all the variables inside the context at once:\n\n\n(f/unpatch-all!)\n\n\n(fc/unpatch-all! ctx)\n\n\nIf you use \nwith-fakes\n then all variables will be unpatched \nautomatically on exiting the block, for instance:\n\n\n(f/with-fakes\n  (f/patch! #'funcs/sum (f/fake [[1 2] \nfoo\n\n                                 [3 4] \nbar\n]))\n  (is (= \nfoo\n (funcs/sum 1 2)))\n  (is (= \nbar\n (funcs/sum 3 4))))\n\n; patching is reverted on exiting with-fakes block\n(is (= 3 (funcs/sum 1 2)))\n\n\n\n\nAnother example is combining \npatch\n and \nrecorded-fake\n in order\nto create a \nfunction spy\n which works exactly the same as the original function\nand also records its calls:\n\n\n(f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))\n\n\n\n\nMonkey patching is not thread-safe because it changes variable \nin all threads \n(underlying implementation uses \n\nalter-var-root\n/\nset!\n).\n\n\nStarting from Clojure 1.8, if \ndirect linking\n is enabled:\n\n\n\n\nyou have to add \n^:redef\n metadata key to functions which you patch;\n\n\nyou can't patch core functions (e.g. \nprintln\n).\n\n\n\n\nReferences\n\n\nThe API was mainly inspired by \njMock\n and \n\nunittest.mock\n frameworks with\ndesign decisions loosely based on the \n\n\"Fifteen things I look for in an Isolation framework\" by Roy Osherove\n.\n\n\nSome alternative frameworks with isolation capabilities:\n\n\n\n\nshrubbery\n\n\nclj-mock\n\n\nconjure\n\n\nMidje\n\n\nspeclj\n\n\n\n\nAlso take at look at the article \n\n\"Isolating External Dependencies in Clojure\" by Joseph Wilk\n.\n\n\nFor more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:\n\n\n\n\n\"Test Driven Development: By Example\" by Kent Beck\n\n\n\"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce [\nsite\n]\n\n\n\"xUnit Test Patterns: Refactoring Test Code\" by Gerard Meszaros [\nsite\n]", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#namespaces", 
            "text": "The public API is split into two namespaces:   clj-fakes.core  clj-fakes.context   This is how you could require them in Clojure and ClojureScript:  ; Clojure\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f]\n    [clj-fakes.context :as fc]))\n\n; ClojureScript\n(ns unit.example\n  (:require\n    [clj-fakes.core :as f :include-macros true]\n    [clj-fakes.context :as fc :include-macros true]))  These namespaces contain almost the same set of members. The difference \nis that  core  uses an implicit context and the  context  namespace\nfunctions require an explicit context argument.  For your convenience functions which don't rely on a context can also be sometimes found in both namespaces (e.g.  f/any?  is the same as  fc/any? ).  The private/internal API uses a  -  prefix and should not be used (e.g.  -this-is-some-private-thing ).", 
            "title": "Namespaces"
        }, 
        {
            "location": "/user-guide/#context", 
            "text": "Context is an object which stores all the information about\ncreated fakes (recorded calls, positions in code, etc.).\nAll fakes have to be created inside some context.  To create a new context use  clj-fakes.context/context :  ; explicit context\n(let [ctx (fc/context)\n      foo (fc/recorded-fake ctx)]\n  ; ...\n)  Alternatively a new context can be created with  clj-fakes.core/with-fakes  macro:  ; implicit context\n(f/with-fakes\n  ; note that now fake is created using a macro from core ns\n  (let [foo (f/recorded-fake)]\n    ; ...\n))  This approach is preferable since it requires less typing, automatically \nunpatches all  patched vars  and executes  self-tests .  Internally  with-fakes  relies on a public dynamic variable  *context*  which can be \nused in your own helper functions.", 
            "title": "Context"
        }, 
        {
            "location": "/user-guide/#function-fakes", 
            "text": "Fake is a function which returns canned values on matched arguments and can optionally record its calls. It \ncan be used to define and assert a behavior of a functional dependency of an SUT (system under test).", 
            "title": "Function Fakes"
        }, 
        {
            "location": "/user-guide/#fake", 
            "text": "A regular fake function can be created using a macro:  (f/fake config)  (fc/fake ctx config)  Config  is a vector which defines which values to return for different arguments:  (let [foo (f/fake [[1 2]  foo \n                   [3 4 5]  bar ])]\n  (foo 1 2) ; =   foo \n  (foo 3 4 5)) ; =   bar   If passed arguments cannot be  matched  using specified \nconfig then the exception will be raised:  (foo 100 200) ; =  raises  Unexpected args are passed into fake: (100 200) ...   A fake is assumed to be called at least once inside the context; otherwise,  self-test  exception \nwill be raised. In such case user should either modify a test, an SUT \nor consider using an  optional fake :  (f/with-fakes\n  (f/fake [[] nil])) ; =  raises  Self-test: no call detected for: non-optional fake ...   If your test scenario focuses on testing a behavior (e.g. \"assert that foo was called by an SUT\") then do not rely on self-tests, \ninstead use  recorded fakes  with explicit  assertions . \nSelf-tests are more about checking usefulness of provided preconditions than \nabout testing expected behavior.", 
            "title": "Fake"
        }, 
        {
            "location": "/user-guide/#optional-fake", 
            "text": "(f/optional-fake [config])  (fc/optional-fake ctx [config])  It works the same as a regular fake but is not expected to be always called in the context:  (f/with-fakes\n  (f/optional-fake [[1 2] 3])) ; =  ok, self-test will pass  Such fakes should be used to express the intent of the test writer, \nfor example, when you have to provide a dependency to an SUT,\nbut this dependency is not really related to the test case:  (defn process-payments\n   Processor requires a logger. \n  [data logger]\n  {:pre [(fn? logger)]}\n  ; ...\n  )\n\n(deftest good-payments-are-processed-without-error\n  (f/with-fakes\n    (let [; ...\n          ; we are not interested in how logger is going to be used, just stub it and forget\n          fake-logger (f/optional-fake)]\n      (is (= :success (process-payments good-payments fake-logger))))))  As you may have noticed,  config  argument can be omitted. \nIn such case fake will be created with  default-fake-config  \nwhich allows any arguments to be passed on invocation.", 
            "title": "Optional Fake"
        }, 
        {
            "location": "/user-guide/#recorded-fake", 
            "text": "Invocations of this fake are recorded so that they can later be asserted:  (f/recorded-fake [config])  (fc/recorded-fake ctx [config])  Use  calls  function in order to get all recorded invocations for the specified \nrecorded fake. \nIt can also return all the recorded calls in the context if fake is not specified:  (let [foo (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(+ %1 %2)])\n      bar (f/recorded-fake [[(f/arg integer?) (f/arg integer?)] #(* %1 %2)])]\n  (foo 1 2)\n  (bar 5 6)\n  (foo 7 8)\n\n  (f/calls foo)\n  ; =  [{:args [1 2] :return-value 3}\n  ;     {:args [7 8] :return-value 15}]\n\n  (f/calls)\n  ; =  [[foo {:args [1 2] :return-value 3}]\n  ;     [bar {:args [5 6] :return-value 30}]\n  ;     [foo {:args [7 8] :return-value 15}]]\n)  Recorded fake must be checked using one of the  assertions  provided by the framework or\nbe marked as checked explicitly using  mark-checked  function; \notherwise,  self-test  will raise an exception:  (f/with-fakes\n  (f/recorded-fake)) ; =  raises  Self-test: no check performed on: recorded fake ...   (f/with-fakes\n  (let [foo (f/recorded-fake)]\n    (foo)\n    (is (f/was-called foo [])))) ; =  ok, self-test will pass  (f/with-fakes\n  (f/mark-checked (f/recorded-fake))) ; =  ok, self-test will pass", 
            "title": "Recorded Fake"
        }, 
        {
            "location": "/user-guide/#custom-macros", 
            "text": "In your own reusable macros you should use  fake*/recorded-fake*  \ninstead of  fake/recorded-fake :  (f/fake* form config)  (fc/fake* ctx form config)  (f/recorded-fake* form [config])  (fc/recorded-fake* ctx form [config])  In other words, your macro must explicitly provide  form  to framework macros; \notherwise, due to implementation details, framework will not be \nable to correctly determine fake function line numbers which is crucial for debugging.   The framework will warn you if you accidentally use the version without asterisk \nin your macro.", 
            "title": "Custom Macros"
        }, 
        {
            "location": "/user-guide/#fake-configuration", 
            "text": "Fake config should contain pairs of  args matcher  and return value:  [args-matcher1 fn-or-value1\nargs-matcher2 fn-or-value2 ...]  On fake invocation matchers will be tested from top to bottom and \non the first match the specified value will be returned. \nIf return value is a function than it will be called with passed arguments to generate the return value at runtime:  (let [foo (f/fake [[1 2] 100\n                   [3 4] #(+ %1 %2)\n                   [5 6] (fn [_ _] (throw (ex-info  wow  {})))])]\n  (foo 1 2) ; =  100\n  (foo 3 4) ; =  7\n  (foo 5 6)) ; =  raises  wow  exception  There's one built-in config in the framework:  fc/default-fake-config  It accepts any number of arguments and returns a new unique \ninstance of type  FakeReturnValue  on each call.\nIt is used by  optional-fake  and  recorded-fake  functions by default (i.e. when user \ndoesn't specify the config explicitly).", 
            "title": "Fake Configuration"
        }, 
        {
            "location": "/user-guide/#helpers", 
            "text": "(f/cyclically coll)  (fc/cyclically coll)  This function can be used to implement iterator-style stubbing \nwhen a fake returns a different value on each call:  (let [get-weekday (f/fake [[ My event ] (f/cyclically [:monday :tuesday :wednesday])])]\n  (is (= :monday (get-weekday  My event )))\n  (is (= :tuesday (get-weekday  My event )))\n  (is (= :wednesday (get-weekday  My event )))\n  (is (= :monday (get-weekday  My event ))))", 
            "title": "Helpers"
        }, 
        {
            "location": "/user-guide/#argument-matching", 
            "text": "Every arguments matcher must implement an  fc/ArgsMatcher  protocol:  (defprotocol ArgsMatcher\n  (args-match? [this args]  Should return true or false. )\n  (args-matcher- str [this]  Should return a string for debug messages. ))  In most cases you won't need to create instances of this protocol manually \nbecause framework provides vector matchers which are useful in most cases.", 
            "title": "Argument Matching"
        }, 
        {
            "location": "/user-guide/#vector-matcher", 
            "text": "Vector matchers were already used all other this guide. \nEach vector element can be an expected value or an  fc/ImplicitArgMatcher  instance:  [implicit-arg-matcher-or-exact-value1 implicit-arg-matcher-or-exact-value2 ...]  (defprotocol ImplicitArgMatcher\n  (arg-matches-implicitly? [this arg]  Should return true or false. )\n  (arg-matcher- str [this]  Should return a string for debug messages. ))  It is not recommended to extend existing types with  ImplicitArgMatcher  protocol; \ninstead, to make code more explicit and future-proof, \nyou should use an  arg  \"adapter\" macro and pass it  ArgMatcher  instances:  (let [foo (f/fake [[]  no args \n                   [[]]  empty vector \n                   [1 2]  1 2 \n                   [(f/arg integer?) (f/arg integer?)]  two integers \n                   [(f/arg string?)]  string ])]\n  (foo) ; =   no args \n  (foo []) ; =   empty vector \n  (foo 1 2) ; =   1 2 \n  (foo 1 2 3) ; =  exception:  Unexpected args are passed into fake: (1 2 3) ... \n  (foo 100 200) ; =   two integers \n  (foo  hey )) ; =   string   As you can see, the framework already supports  functional argument matchers  \nwhich are implemented by extending function type like this:  (extend-type #?(:clj  clojure.lang.Fn\n                :cljs function)\n  ArgMatcher\n  (arg-matches? [this arg]\n    (this arg)))  You are encouraged to define your own argument matchers in a similar way.  The framework also supports  regex matchers  (using  re-find  under the hood), for example:  (f/arg #\"abc.*\") .", 
            "title": "Vector Matcher"
        }, 
        {
            "location": "/user-guide/#any", 
            "text": "(f/any? _)  (fc/any? _)  This special matcher always returns  true  for any input arguments. \nIt can be used to match single and multiple arguments:  (let [foo (f/fake [[1 2]  1 2 \n                   [f/any? f/any? f/any?]  three args \n                   f/any?  something else ])]\n  (foo) ; =   something else \n  (foo 1) ; =   something else \n  (foo 1 2) ; =   1 2 \n  (foo 1 2 3) ; =   three args \n  (foo 1 2 3 4)) ; =   something else", 
            "title": "any?"
        }, 
        {
            "location": "/user-guide/#protocol-fakes", 
            "text": "Framework defines two new macros for reifying protocols \nusing function fakes described earlier. So, for example, \nyou can record and assert method calls on reified instances.  The \"strict\"  reify-fake  macro is very similar to  reify ; in particular, \ncreated instance will raise an exception \non calling protocol method which is not defined.   On the other hand,  reify-nice-fake  is able to automatically \ngenerate  optional-fake  implementations for methods which are \nnot explicitly defined by user.   Which macro to use solely depends on your testing style. I'd \nrecommend to use nice fakes whenever possible in order to make \ntests more compact and break less often on code changes.  There are some subtleties, so here's a table to give you an overview of \nwhich features are currently supported:     Feature  reify-fake  reify-nice-fake      Fake protocol method (explicitly)  Yes  Yes    Fake protocol method (auto)  -  Yes    Fake Java interface method (explicitly)  Yes  Yes    Fake Java interface method (auto)  -  No    Fake Object method (explicitly)  Yes  Only in Clojure    Fake Object method (auto)  -  No    Object can be reified with any new methods  Only in ClojureScript  Only in ClojureScript    Support overloaded methods  Yes  Yes", 
            "title": "Protocol Fakes"
        }, 
        {
            "location": "/user-guide/#syntax", 
            "text": "The syntax is very similar to the built-in  reify  macro:  (f/reify-fake specs*)  (fc/reify-fake ctx specs*)  (f/reify-nice-fake specs*)  (fc/reify-nice-fake ctx specs*)  Each spec consists of the protocol or interface name followed by zero\nor more method fakes:  protocol-or-interface-or-Object\n(method-name [arglist] fake-type [config])*  Available fake types:   :fake  (see  Fake )  :optional-fake  (see  Optional Fake )  :recorded-fake  (see  Recorded Fake )   As with function fakes, config can be omitted for  :optional-fake  and  :recorded-fake :  (defprotocol AnimalProtocol\n  (speak [this] [this name] [this name1 name2])\n  (eat [this food drink])\n  (sleep [this]))\n\n(defprotocol FileProtocol\n  (save [this])\n  (scan [this]))\n\n; ...\n\n(f/reify-fake\n  p/AnimalProtocol\n  (sleep :fake [f/any?  zzz ])\n  (speak :recorded-fake)\n\n  p/FileProtocol\n  (save :optional-fake)\n\n  java.lang.CharSequence\n  (charAt :recorded-fake [f/any? \\a]))  Although protocol methods always have a first  this  argument, \nmethod configs must not try to match this argument. \nHowever, the return value function will receive all the arguments on invocation, \nincluding  this :  (let [monkey (f/reify-fake p/AnimalProtocol\n                           ; config only matches |food| and |drink| arguments\n                           ; but return value function will get all 3 arguments on call\n                           (eat :fake [[f/any? f/any?] #(str  ate   %2   and drank   %3)]))]\n      (println (p/eat monkey  banana   water ))) ; =  ate banana and drank water  In ClojureScript it's possible to implement any methods under  Object  protocol.\nThe framework supports this scenario but requires an arglist explicitly specified after the method name\n( this  arg should be omitted):  (let [calculator (f/reify-fake Object\n                               (sum [x y] :fake [[f/any? f/any?] #(+ %2 %3)]))]\n  (is (= 5 (.sum calculator 2 3))))", 
            "title": "Syntax"
        }, 
        {
            "location": "/user-guide/#calls-assertions", 
            "text": "In order to get and assert recorded method calls there's a \nhelper function:  (f/method obj f)  (fc/method ctx obj f)  It can be used in combination with existing  calls  and  was-called-*  functions like this:  (f/with-fakes\n  (let [cow (f/reify-fake p/AnimalProtocol\n                          (speak :recorded-fake [f/any?  moo ]))]\n    (p/speak cow)\n    (println (f/calls (f/method cow p/speak))) ; =  [{:args ..., :return-value moo}]\n    (is (f/was-called-once (f/method cow p/speak) [cow]))))  Notice how object name  cow  is duplicated at the last line. In order to get \nrid of such duplications there are additional  method-*  assertions defined. \nSo the last expression can be rewritten like this:  (is (f/method-was-called-once p/speak cow []))  For the list of all available assertion functions see  Assertions .  There's a quirk when Java interface or ClojureScript  Object  method is faked: you will need to use its\nstring representation in  method / method-* :  (let [foo (f/reify-fake clojure.lang.IFn\n                        (invoke :recorded-fake))]\n  (foo 1 2 3)\n  (is (f/method-was-called  invoke  foo [1 2 3])))", 
            "title": "Calls &amp; Assertions"
        }, 
        {
            "location": "/user-guide/#custom-macros_1", 
            "text": "In your own reusable macros you should use  reify-fake*/reify-nice-fake*  \ninstead of  reify-fake/reify-nice-fake :  (f/reify-fake* form env specs*)  (fc/reify-fake* ctx form env specs*)  (f/reify-nice-fake* form env specs*)  (fc/reify-nice-fake* ctx form env specs*)  In other words, your macro must explicitly provide  form  and  env  to framework macros; \notherwise, due to implementation details, framework will not be \nable to correctly determine fake method line numbers which is crucial for debugging.   For instance:  (defmacro my-reify-fake\n  [  specs]\n  `(f/reify-fake* ~ form ~ env ~@specs))  The framework will warn you if you accidentally use the version without asterisk \nin your macro.", 
            "title": "Custom Macros"
        }, 
        {
            "location": "/user-guide/#assertions", 
            "text": "Framework provides several assertion functions for  recorded fakes . \nEach function either returns  true  or raises an exception with additional details:  (f/was-called-once f args-matcher) \n- checks that function was called strictly once and that the call was with the specified args.  (f/was-called f args-matcher) \n- checks that function was called at least once with the specified args.  (f/was-not-called f) \n- checks that function was never called.  (f/were-called-in-order f1 args-matcher1 f2 args-matcher2 ...) \n- checks that functions were called in specified order (but it doesn't guarantee there were no other calls).  The set of similar functions is defined for  protocol methods :  (f/method-was-called-once f obj args-matcher)  (f/method-was-called f obj args-matcher)  (f/method-was-not-called f obj)  (f/methods-were-called-in-order f1 obj1 args-matcher1 f2 obj2 args-matcher2 ...)  Of course, all these functions can be called with an explicit context:  (fc/was-called-once ctx f args-matcher)  (fc/was-called ctx f args-matcher)  (fc/was-not-called ctx f)  (fc/were-called-in-order ctx f1 args-matcher1 f2 args-matcher2 ...)  (fc/method-was-called-once ctx f obj args-matcher)  (fc/method-was-called ctx f obj args-matcher)  (fc/method-was-not-called ctx f obj)  (fc/methods-were-called-in-order ctx f1 obj1 args-matcher1 f2 obj2 args-matcher2 ...)", 
            "title": "Assertions"
        }, 
        {
            "location": "/user-guide/#self-tests", 
            "text": "Framework can perform \"self-tests\" in order to inform a user \nearly on that some fakes (including protocol method fakes) are potentially used inappropriately.  If you use  with-fakes  macro then self-tests will be run automatically on exiting the block.\nOtherwise, when  explicit context  is used, you have to invoke self-tests manually\nusing next function:  (fc/self-test ctx)  Each test can also be run manually using dedicated functions.\nCurrently two types of self-tests are supported to identify:   unused fakes   unchecked fakes", 
            "title": "Self-tests"
        }, 
        {
            "location": "/user-guide/#unused-fakes", 
            "text": "(fc/self-test-unused-fakes ctx)  This function raises an exception when some  fake  was never called after its creation.  For example, this self-test comes in handy when SUT stops using a dependency which \nwas faked in several test scenarios. In such case the framework will guide you in cleaning \n your test suite from the unused stubs.", 
            "title": "Unused Fakes"
        }, 
        {
            "location": "/user-guide/#unchecked-fakes", 
            "text": "(fc/self-test-unchecked-fakes ctx)  This self-test raises an exception if some  recorded-fake  \nwas never  marked checked , i.e. you forgot to assert its calls.", 
            "title": "Unchecked Fakes"
        }, 
        {
            "location": "/user-guide/#monkey-patching", 
            "text": "You can temporarily change a variable value by using  patch!  macro:  (f/patch! var-expr val)  (fc/patch! ctx var-expr val)  After patching original value can still be obtained using a function:  (f/original-val a-var)  (fc/original-val ctx a-var)  Also don't forget to unpatch the variable to recover its original value:  (f/unpatch! var-expr)  (fc/unpatch! ctx var-expr)  Or unpatch all the variables inside the context at once:  (f/unpatch-all!)  (fc/unpatch-all! ctx)  If you use  with-fakes  then all variables will be unpatched \nautomatically on exiting the block, for instance:  (f/with-fakes\n  (f/patch! #'funcs/sum (f/fake [[1 2]  foo \n                                 [3 4]  bar ]))\n  (is (=  foo  (funcs/sum 1 2)))\n  (is (=  bar  (funcs/sum 3 4))))\n\n; patching is reverted on exiting with-fakes block\n(is (= 3 (funcs/sum 1 2)))  Another example is combining  patch  and  recorded-fake  in order\nto create a  function spy  which works exactly the same as the original function\nand also records its calls:  (f/patch! #'funcs/sum (f/recorded-fake [f/any? funcs/sum]))  Monkey patching is not thread-safe because it changes variable \nin all threads \n(underlying implementation uses  alter-var-root / set! ).  Starting from Clojure 1.8, if  direct linking  is enabled:   you have to add  ^:redef  metadata key to functions which you patch;  you can't patch core functions (e.g.  println ).", 
            "title": "Monkey Patching"
        }, 
        {
            "location": "/user-guide/#references", 
            "text": "The API was mainly inspired by  jMock  and  unittest.mock  frameworks with\ndesign decisions loosely based on the  \"Fifteen things I look for in an Isolation framework\" by Roy Osherove .  Some alternative frameworks with isolation capabilities:   shrubbery  clj-mock  conjure  Midje  speclj   Also take at look at the article  \"Isolating External Dependencies in Clojure\" by Joseph Wilk .  For more detailed information about unit testing, TDD and test double patterns I'd recommend the books below:   \"Test Driven Development: By Example\" by Kent Beck  \"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce [ site ]  \"xUnit Test Patterns: Refactoring Test Code\" by Gerard Meszaros [ site ]", 
            "title": "References"
        }, 
        {
            "location": "/api/", 
            "text": "It is a placeholder file, \nit will be replaced by API Reference docs generated by external tool.", 
            "title": "API Reference"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Tests\n\n\nAutorun Clojure tests: \nlein test-refresh\n\n\nRun ClojureScript tests: \nlein clean \n lein doo phantom test once\n\n(clean is needed because there's an \nissue\n: plugin does not seem to recompile macros)\n\n\nUse \nmin-deps\n profile to test with minimal supported dependencies (instead of default and usually latest versions):\n\n\nlein with-profiles +min-deps test-refresh\n\n\nlein clean \n lein with-profiles +min-deps doo phantom test once\n\n\nDocumentation\n\n\nProject uses \nMkDocs\n with \nCinder\n theme to generate documentation static site and \n\nCodox\n for API reference.\nTasks are scripted using \nPyInvoke\n.\n\n\nServe site pages locally with automatic build (but it won't work for index page): \nmkdocs serve\n\n\nBuild only site pages: \ninv mkdocs\n\n\nBuild API reference into site folder: \ninv api\n\n\nBuild the whole site: \ninv site\n\n\nDeploying\n\n\nDeploy to Clojars: \nlein deploy clojars\n\n\nDeploy site to gh-pages branch: \nghp-import -p site", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#tests", 
            "text": "Autorun Clojure tests:  lein test-refresh  Run ClojureScript tests:  lein clean   lein doo phantom test once \n(clean is needed because there's an  issue : plugin does not seem to recompile macros)  Use  min-deps  profile to test with minimal supported dependencies (instead of default and usually latest versions):  lein with-profiles +min-deps test-refresh  lein clean   lein with-profiles +min-deps doo phantom test once", 
            "title": "Tests"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  with  Cinder  theme to generate documentation static site and  Codox  for API reference.\nTasks are scripted using  PyInvoke .  Serve site pages locally with automatic build (but it won't work for index page):  mkdocs serve  Build only site pages:  inv mkdocs  Build API reference into site folder:  inv api  Build the whole site:  inv site", 
            "title": "Documentation"
        }, 
        {
            "location": "/dev-guide/#deploying", 
            "text": "Deploy to Clojars:  lein deploy clojars  Deploy site to gh-pages branch:  ghp-import -p site", 
            "title": "Deploying"
        }
    ]
}